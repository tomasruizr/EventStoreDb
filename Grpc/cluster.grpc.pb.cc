// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: cluster.proto

#include "cluster.pb.h"
#include "cluster.grpc.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/channel_interface.h>
#include <grpcpp/impl/codegen/client_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/rpc_service_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/sync_stream.h>
namespace event_store {
namespace cluster {

static const char* Gossip_method_names[] = {
  "/event_store.cluster.Gossip/Update",
  "/event_store.cluster.Gossip/Read",
};

std::unique_ptr< Gossip::Stub> Gossip::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr< Gossip::Stub> stub(new Gossip::Stub(channel));
  return stub;
}

Gossip::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel)
  : channel_(channel), rpcmethod_Update_(Gossip_method_names[0], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_Read_(Gossip_method_names[1], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  {}

::grpc::Status Gossip::Stub::Update(::grpc::ClientContext* context, const ::event_store::cluster::GossipRequest& request, ::event_store::cluster::ClusterInfo* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_Update_, context, request, response);
}

void Gossip::Stub::experimental_async::Update(::grpc::ClientContext* context, const ::event_store::cluster::GossipRequest* request, ::event_store::cluster::ClusterInfo* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_Update_, context, request, response, std::move(f));
}

void Gossip::Stub::experimental_async::Update(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::cluster::ClusterInfo* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_Update_, context, request, response, std::move(f));
}

void Gossip::Stub::experimental_async::Update(::grpc::ClientContext* context, const ::event_store::cluster::GossipRequest* request, ::event_store::cluster::ClusterInfo* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_Update_, context, request, response, reactor);
}

void Gossip::Stub::experimental_async::Update(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::cluster::ClusterInfo* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_Update_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::event_store::cluster::ClusterInfo>* Gossip::Stub::AsyncUpdateRaw(::grpc::ClientContext* context, const ::event_store::cluster::GossipRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::event_store::cluster::ClusterInfo>::Create(channel_.get(), cq, rpcmethod_Update_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::event_store::cluster::ClusterInfo>* Gossip::Stub::PrepareAsyncUpdateRaw(::grpc::ClientContext* context, const ::event_store::cluster::GossipRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::event_store::cluster::ClusterInfo>::Create(channel_.get(), cq, rpcmethod_Update_, context, request, false);
}

::grpc::Status Gossip::Stub::Read(::grpc::ClientContext* context, const ::event_store::client::Empty& request, ::event_store::cluster::ClusterInfo* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_Read_, context, request, response);
}

void Gossip::Stub::experimental_async::Read(::grpc::ClientContext* context, const ::event_store::client::Empty* request, ::event_store::cluster::ClusterInfo* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_Read_, context, request, response, std::move(f));
}

void Gossip::Stub::experimental_async::Read(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::cluster::ClusterInfo* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_Read_, context, request, response, std::move(f));
}

void Gossip::Stub::experimental_async::Read(::grpc::ClientContext* context, const ::event_store::client::Empty* request, ::event_store::cluster::ClusterInfo* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_Read_, context, request, response, reactor);
}

void Gossip::Stub::experimental_async::Read(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::cluster::ClusterInfo* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_Read_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::event_store::cluster::ClusterInfo>* Gossip::Stub::AsyncReadRaw(::grpc::ClientContext* context, const ::event_store::client::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::event_store::cluster::ClusterInfo>::Create(channel_.get(), cq, rpcmethod_Read_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::event_store::cluster::ClusterInfo>* Gossip::Stub::PrepareAsyncReadRaw(::grpc::ClientContext* context, const ::event_store::client::Empty& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::event_store::cluster::ClusterInfo>::Create(channel_.get(), cq, rpcmethod_Read_, context, request, false);
}

Gossip::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      Gossip_method_names[0],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< Gossip::Service, ::event_store::cluster::GossipRequest, ::event_store::cluster::ClusterInfo>(
          [](Gossip::Service* service,
             ::grpc_impl::ServerContext* ctx,
             const ::event_store::cluster::GossipRequest* req,
             ::event_store::cluster::ClusterInfo* resp) {
               return service->Update(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      Gossip_method_names[1],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< Gossip::Service, ::event_store::client::Empty, ::event_store::cluster::ClusterInfo>(
          [](Gossip::Service* service,
             ::grpc_impl::ServerContext* ctx,
             const ::event_store::client::Empty* req,
             ::event_store::cluster::ClusterInfo* resp) {
               return service->Read(ctx, req, resp);
             }, this)));
}

Gossip::Service::~Service() {
}

::grpc::Status Gossip::Service::Update(::grpc::ServerContext* context, const ::event_store::cluster::GossipRequest* request, ::event_store::cluster::ClusterInfo* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status Gossip::Service::Read(::grpc::ServerContext* context, const ::event_store::client::Empty* request, ::event_store::cluster::ClusterInfo* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}


static const char* Elections_method_names[] = {
  "/event_store.cluster.Elections/ViewChange",
  "/event_store.cluster.Elections/ViewChangeProof",
  "/event_store.cluster.Elections/Prepare",
  "/event_store.cluster.Elections/PrepareOk",
  "/event_store.cluster.Elections/Proposal",
  "/event_store.cluster.Elections/Accept",
  "/event_store.cluster.Elections/LeaderIsResigning",
  "/event_store.cluster.Elections/LeaderIsResigningOk",
};

std::unique_ptr< Elections::Stub> Elections::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr< Elections::Stub> stub(new Elections::Stub(channel));
  return stub;
}

Elections::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel)
  : channel_(channel), rpcmethod_ViewChange_(Elections_method_names[0], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_ViewChangeProof_(Elections_method_names[1], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_Prepare_(Elections_method_names[2], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_PrepareOk_(Elections_method_names[3], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_Proposal_(Elections_method_names[4], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_Accept_(Elections_method_names[5], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_LeaderIsResigning_(Elections_method_names[6], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_LeaderIsResigningOk_(Elections_method_names[7], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  {}

::grpc::Status Elections::Stub::ViewChange(::grpc::ClientContext* context, const ::event_store::cluster::ViewChangeRequest& request, ::event_store::client::Empty* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_ViewChange_, context, request, response);
}

void Elections::Stub::experimental_async::ViewChange(::grpc::ClientContext* context, const ::event_store::cluster::ViewChangeRequest* request, ::event_store::client::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_ViewChange_, context, request, response, std::move(f));
}

void Elections::Stub::experimental_async::ViewChange(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_ViewChange_, context, request, response, std::move(f));
}

void Elections::Stub::experimental_async::ViewChange(::grpc::ClientContext* context, const ::event_store::cluster::ViewChangeRequest* request, ::event_store::client::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_ViewChange_, context, request, response, reactor);
}

void Elections::Stub::experimental_async::ViewChange(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_ViewChange_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::event_store::client::Empty>* Elections::Stub::AsyncViewChangeRaw(::grpc::ClientContext* context, const ::event_store::cluster::ViewChangeRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::event_store::client::Empty>::Create(channel_.get(), cq, rpcmethod_ViewChange_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::event_store::client::Empty>* Elections::Stub::PrepareAsyncViewChangeRaw(::grpc::ClientContext* context, const ::event_store::cluster::ViewChangeRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::event_store::client::Empty>::Create(channel_.get(), cq, rpcmethod_ViewChange_, context, request, false);
}

::grpc::Status Elections::Stub::ViewChangeProof(::grpc::ClientContext* context, const ::event_store::cluster::ViewChangeProofRequest& request, ::event_store::client::Empty* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_ViewChangeProof_, context, request, response);
}

void Elections::Stub::experimental_async::ViewChangeProof(::grpc::ClientContext* context, const ::event_store::cluster::ViewChangeProofRequest* request, ::event_store::client::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_ViewChangeProof_, context, request, response, std::move(f));
}

void Elections::Stub::experimental_async::ViewChangeProof(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_ViewChangeProof_, context, request, response, std::move(f));
}

void Elections::Stub::experimental_async::ViewChangeProof(::grpc::ClientContext* context, const ::event_store::cluster::ViewChangeProofRequest* request, ::event_store::client::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_ViewChangeProof_, context, request, response, reactor);
}

void Elections::Stub::experimental_async::ViewChangeProof(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_ViewChangeProof_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::event_store::client::Empty>* Elections::Stub::AsyncViewChangeProofRaw(::grpc::ClientContext* context, const ::event_store::cluster::ViewChangeProofRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::event_store::client::Empty>::Create(channel_.get(), cq, rpcmethod_ViewChangeProof_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::event_store::client::Empty>* Elections::Stub::PrepareAsyncViewChangeProofRaw(::grpc::ClientContext* context, const ::event_store::cluster::ViewChangeProofRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::event_store::client::Empty>::Create(channel_.get(), cq, rpcmethod_ViewChangeProof_, context, request, false);
}

::grpc::Status Elections::Stub::Prepare(::grpc::ClientContext* context, const ::event_store::cluster::PrepareRequest& request, ::event_store::client::Empty* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_Prepare_, context, request, response);
}

void Elections::Stub::experimental_async::Prepare(::grpc::ClientContext* context, const ::event_store::cluster::PrepareRequest* request, ::event_store::client::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_Prepare_, context, request, response, std::move(f));
}

void Elections::Stub::experimental_async::Prepare(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_Prepare_, context, request, response, std::move(f));
}

void Elections::Stub::experimental_async::Prepare(::grpc::ClientContext* context, const ::event_store::cluster::PrepareRequest* request, ::event_store::client::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_Prepare_, context, request, response, reactor);
}

void Elections::Stub::experimental_async::Prepare(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_Prepare_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::event_store::client::Empty>* Elections::Stub::AsyncPrepareRaw(::grpc::ClientContext* context, const ::event_store::cluster::PrepareRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::event_store::client::Empty>::Create(channel_.get(), cq, rpcmethod_Prepare_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::event_store::client::Empty>* Elections::Stub::PrepareAsyncPrepareRaw(::grpc::ClientContext* context, const ::event_store::cluster::PrepareRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::event_store::client::Empty>::Create(channel_.get(), cq, rpcmethod_Prepare_, context, request, false);
}

::grpc::Status Elections::Stub::PrepareOk(::grpc::ClientContext* context, const ::event_store::cluster::PrepareOkRequest& request, ::event_store::client::Empty* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_PrepareOk_, context, request, response);
}

void Elections::Stub::experimental_async::PrepareOk(::grpc::ClientContext* context, const ::event_store::cluster::PrepareOkRequest* request, ::event_store::client::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_PrepareOk_, context, request, response, std::move(f));
}

void Elections::Stub::experimental_async::PrepareOk(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_PrepareOk_, context, request, response, std::move(f));
}

void Elections::Stub::experimental_async::PrepareOk(::grpc::ClientContext* context, const ::event_store::cluster::PrepareOkRequest* request, ::event_store::client::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_PrepareOk_, context, request, response, reactor);
}

void Elections::Stub::experimental_async::PrepareOk(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_PrepareOk_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::event_store::client::Empty>* Elections::Stub::AsyncPrepareOkRaw(::grpc::ClientContext* context, const ::event_store::cluster::PrepareOkRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::event_store::client::Empty>::Create(channel_.get(), cq, rpcmethod_PrepareOk_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::event_store::client::Empty>* Elections::Stub::PrepareAsyncPrepareOkRaw(::grpc::ClientContext* context, const ::event_store::cluster::PrepareOkRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::event_store::client::Empty>::Create(channel_.get(), cq, rpcmethod_PrepareOk_, context, request, false);
}

::grpc::Status Elections::Stub::Proposal(::grpc::ClientContext* context, const ::event_store::cluster::ProposalRequest& request, ::event_store::client::Empty* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_Proposal_, context, request, response);
}

void Elections::Stub::experimental_async::Proposal(::grpc::ClientContext* context, const ::event_store::cluster::ProposalRequest* request, ::event_store::client::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_Proposal_, context, request, response, std::move(f));
}

void Elections::Stub::experimental_async::Proposal(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_Proposal_, context, request, response, std::move(f));
}

void Elections::Stub::experimental_async::Proposal(::grpc::ClientContext* context, const ::event_store::cluster::ProposalRequest* request, ::event_store::client::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_Proposal_, context, request, response, reactor);
}

void Elections::Stub::experimental_async::Proposal(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_Proposal_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::event_store::client::Empty>* Elections::Stub::AsyncProposalRaw(::grpc::ClientContext* context, const ::event_store::cluster::ProposalRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::event_store::client::Empty>::Create(channel_.get(), cq, rpcmethod_Proposal_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::event_store::client::Empty>* Elections::Stub::PrepareAsyncProposalRaw(::grpc::ClientContext* context, const ::event_store::cluster::ProposalRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::event_store::client::Empty>::Create(channel_.get(), cq, rpcmethod_Proposal_, context, request, false);
}

::grpc::Status Elections::Stub::Accept(::grpc::ClientContext* context, const ::event_store::cluster::AcceptRequest& request, ::event_store::client::Empty* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_Accept_, context, request, response);
}

void Elections::Stub::experimental_async::Accept(::grpc::ClientContext* context, const ::event_store::cluster::AcceptRequest* request, ::event_store::client::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_Accept_, context, request, response, std::move(f));
}

void Elections::Stub::experimental_async::Accept(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_Accept_, context, request, response, std::move(f));
}

void Elections::Stub::experimental_async::Accept(::grpc::ClientContext* context, const ::event_store::cluster::AcceptRequest* request, ::event_store::client::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_Accept_, context, request, response, reactor);
}

void Elections::Stub::experimental_async::Accept(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_Accept_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::event_store::client::Empty>* Elections::Stub::AsyncAcceptRaw(::grpc::ClientContext* context, const ::event_store::cluster::AcceptRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::event_store::client::Empty>::Create(channel_.get(), cq, rpcmethod_Accept_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::event_store::client::Empty>* Elections::Stub::PrepareAsyncAcceptRaw(::grpc::ClientContext* context, const ::event_store::cluster::AcceptRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::event_store::client::Empty>::Create(channel_.get(), cq, rpcmethod_Accept_, context, request, false);
}

::grpc::Status Elections::Stub::LeaderIsResigning(::grpc::ClientContext* context, const ::event_store::cluster::LeaderIsResigningRequest& request, ::event_store::client::Empty* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_LeaderIsResigning_, context, request, response);
}

void Elections::Stub::experimental_async::LeaderIsResigning(::grpc::ClientContext* context, const ::event_store::cluster::LeaderIsResigningRequest* request, ::event_store::client::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_LeaderIsResigning_, context, request, response, std::move(f));
}

void Elections::Stub::experimental_async::LeaderIsResigning(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_LeaderIsResigning_, context, request, response, std::move(f));
}

void Elections::Stub::experimental_async::LeaderIsResigning(::grpc::ClientContext* context, const ::event_store::cluster::LeaderIsResigningRequest* request, ::event_store::client::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_LeaderIsResigning_, context, request, response, reactor);
}

void Elections::Stub::experimental_async::LeaderIsResigning(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_LeaderIsResigning_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::event_store::client::Empty>* Elections::Stub::AsyncLeaderIsResigningRaw(::grpc::ClientContext* context, const ::event_store::cluster::LeaderIsResigningRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::event_store::client::Empty>::Create(channel_.get(), cq, rpcmethod_LeaderIsResigning_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::event_store::client::Empty>* Elections::Stub::PrepareAsyncLeaderIsResigningRaw(::grpc::ClientContext* context, const ::event_store::cluster::LeaderIsResigningRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::event_store::client::Empty>::Create(channel_.get(), cq, rpcmethod_LeaderIsResigning_, context, request, false);
}

::grpc::Status Elections::Stub::LeaderIsResigningOk(::grpc::ClientContext* context, const ::event_store::cluster::LeaderIsResigningOkRequest& request, ::event_store::client::Empty* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_LeaderIsResigningOk_, context, request, response);
}

void Elections::Stub::experimental_async::LeaderIsResigningOk(::grpc::ClientContext* context, const ::event_store::cluster::LeaderIsResigningOkRequest* request, ::event_store::client::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_LeaderIsResigningOk_, context, request, response, std::move(f));
}

void Elections::Stub::experimental_async::LeaderIsResigningOk(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::Empty* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_LeaderIsResigningOk_, context, request, response, std::move(f));
}

void Elections::Stub::experimental_async::LeaderIsResigningOk(::grpc::ClientContext* context, const ::event_store::cluster::LeaderIsResigningOkRequest* request, ::event_store::client::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_LeaderIsResigningOk_, context, request, response, reactor);
}

void Elections::Stub::experimental_async::LeaderIsResigningOk(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_LeaderIsResigningOk_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::event_store::client::Empty>* Elections::Stub::AsyncLeaderIsResigningOkRaw(::grpc::ClientContext* context, const ::event_store::cluster::LeaderIsResigningOkRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::event_store::client::Empty>::Create(channel_.get(), cq, rpcmethod_LeaderIsResigningOk_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::event_store::client::Empty>* Elections::Stub::PrepareAsyncLeaderIsResigningOkRaw(::grpc::ClientContext* context, const ::event_store::cluster::LeaderIsResigningOkRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::event_store::client::Empty>::Create(channel_.get(), cq, rpcmethod_LeaderIsResigningOk_, context, request, false);
}

Elections::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      Elections_method_names[0],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< Elections::Service, ::event_store::cluster::ViewChangeRequest, ::event_store::client::Empty>(
          [](Elections::Service* service,
             ::grpc_impl::ServerContext* ctx,
             const ::event_store::cluster::ViewChangeRequest* req,
             ::event_store::client::Empty* resp) {
               return service->ViewChange(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      Elections_method_names[1],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< Elections::Service, ::event_store::cluster::ViewChangeProofRequest, ::event_store::client::Empty>(
          [](Elections::Service* service,
             ::grpc_impl::ServerContext* ctx,
             const ::event_store::cluster::ViewChangeProofRequest* req,
             ::event_store::client::Empty* resp) {
               return service->ViewChangeProof(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      Elections_method_names[2],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< Elections::Service, ::event_store::cluster::PrepareRequest, ::event_store::client::Empty>(
          [](Elections::Service* service,
             ::grpc_impl::ServerContext* ctx,
             const ::event_store::cluster::PrepareRequest* req,
             ::event_store::client::Empty* resp) {
               return service->Prepare(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      Elections_method_names[3],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< Elections::Service, ::event_store::cluster::PrepareOkRequest, ::event_store::client::Empty>(
          [](Elections::Service* service,
             ::grpc_impl::ServerContext* ctx,
             const ::event_store::cluster::PrepareOkRequest* req,
             ::event_store::client::Empty* resp) {
               return service->PrepareOk(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      Elections_method_names[4],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< Elections::Service, ::event_store::cluster::ProposalRequest, ::event_store::client::Empty>(
          [](Elections::Service* service,
             ::grpc_impl::ServerContext* ctx,
             const ::event_store::cluster::ProposalRequest* req,
             ::event_store::client::Empty* resp) {
               return service->Proposal(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      Elections_method_names[5],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< Elections::Service, ::event_store::cluster::AcceptRequest, ::event_store::client::Empty>(
          [](Elections::Service* service,
             ::grpc_impl::ServerContext* ctx,
             const ::event_store::cluster::AcceptRequest* req,
             ::event_store::client::Empty* resp) {
               return service->Accept(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      Elections_method_names[6],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< Elections::Service, ::event_store::cluster::LeaderIsResigningRequest, ::event_store::client::Empty>(
          [](Elections::Service* service,
             ::grpc_impl::ServerContext* ctx,
             const ::event_store::cluster::LeaderIsResigningRequest* req,
             ::event_store::client::Empty* resp) {
               return service->LeaderIsResigning(ctx, req, resp);
             }, this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      Elections_method_names[7],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< Elections::Service, ::event_store::cluster::LeaderIsResigningOkRequest, ::event_store::client::Empty>(
          [](Elections::Service* service,
             ::grpc_impl::ServerContext* ctx,
             const ::event_store::cluster::LeaderIsResigningOkRequest* req,
             ::event_store::client::Empty* resp) {
               return service->LeaderIsResigningOk(ctx, req, resp);
             }, this)));
}

Elections::Service::~Service() {
}

::grpc::Status Elections::Service::ViewChange(::grpc::ServerContext* context, const ::event_store::cluster::ViewChangeRequest* request, ::event_store::client::Empty* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status Elections::Service::ViewChangeProof(::grpc::ServerContext* context, const ::event_store::cluster::ViewChangeProofRequest* request, ::event_store::client::Empty* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status Elections::Service::Prepare(::grpc::ServerContext* context, const ::event_store::cluster::PrepareRequest* request, ::event_store::client::Empty* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status Elections::Service::PrepareOk(::grpc::ServerContext* context, const ::event_store::cluster::PrepareOkRequest* request, ::event_store::client::Empty* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status Elections::Service::Proposal(::grpc::ServerContext* context, const ::event_store::cluster::ProposalRequest* request, ::event_store::client::Empty* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status Elections::Service::Accept(::grpc::ServerContext* context, const ::event_store::cluster::AcceptRequest* request, ::event_store::client::Empty* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status Elections::Service::LeaderIsResigning(::grpc::ServerContext* context, const ::event_store::cluster::LeaderIsResigningRequest* request, ::event_store::client::Empty* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status Elections::Service::LeaderIsResigningOk(::grpc::ServerContext* context, const ::event_store::cluster::LeaderIsResigningOkRequest* request, ::event_store::client::Empty* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}


}  // namespace event_store
}  // namespace cluster

