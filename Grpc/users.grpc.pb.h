// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: users.proto
#ifndef GRPC_users_2eproto__INCLUDED
#define GRPC_users_2eproto__INCLUDED

#include "users.pb.h"

#include <functional>
#include <grpc/impl/codegen/port_platform.h>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace event_store {
namespace client {
namespace users {

class Users final {
 public:
  static constexpr char const* service_full_name() {
    return "event_store.client.users.Users";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status Create(::grpc::ClientContext* context, const ::event_store::client::users::CreateReq& request, ::event_store::client::users::CreateResp* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::event_store::client::users::CreateResp>> AsyncCreate(::grpc::ClientContext* context, const ::event_store::client::users::CreateReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::event_store::client::users::CreateResp>>(AsyncCreateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::event_store::client::users::CreateResp>> PrepareAsyncCreate(::grpc::ClientContext* context, const ::event_store::client::users::CreateReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::event_store::client::users::CreateResp>>(PrepareAsyncCreateRaw(context, request, cq));
    }
    virtual ::grpc::Status Update(::grpc::ClientContext* context, const ::event_store::client::users::UpdateReq& request, ::event_store::client::users::UpdateResp* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::event_store::client::users::UpdateResp>> AsyncUpdate(::grpc::ClientContext* context, const ::event_store::client::users::UpdateReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::event_store::client::users::UpdateResp>>(AsyncUpdateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::event_store::client::users::UpdateResp>> PrepareAsyncUpdate(::grpc::ClientContext* context, const ::event_store::client::users::UpdateReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::event_store::client::users::UpdateResp>>(PrepareAsyncUpdateRaw(context, request, cq));
    }
    virtual ::grpc::Status Delete(::grpc::ClientContext* context, const ::event_store::client::users::DeleteReq& request, ::event_store::client::users::DeleteResp* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::event_store::client::users::DeleteResp>> AsyncDelete(::grpc::ClientContext* context, const ::event_store::client::users::DeleteReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::event_store::client::users::DeleteResp>>(AsyncDeleteRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::event_store::client::users::DeleteResp>> PrepareAsyncDelete(::grpc::ClientContext* context, const ::event_store::client::users::DeleteReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::event_store::client::users::DeleteResp>>(PrepareAsyncDeleteRaw(context, request, cq));
    }
    virtual ::grpc::Status Disable(::grpc::ClientContext* context, const ::event_store::client::users::DisableReq& request, ::event_store::client::users::DisableResp* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::event_store::client::users::DisableResp>> AsyncDisable(::grpc::ClientContext* context, const ::event_store::client::users::DisableReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::event_store::client::users::DisableResp>>(AsyncDisableRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::event_store::client::users::DisableResp>> PrepareAsyncDisable(::grpc::ClientContext* context, const ::event_store::client::users::DisableReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::event_store::client::users::DisableResp>>(PrepareAsyncDisableRaw(context, request, cq));
    }
    virtual ::grpc::Status Enable(::grpc::ClientContext* context, const ::event_store::client::users::EnableReq& request, ::event_store::client::users::EnableResp* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::event_store::client::users::EnableResp>> AsyncEnable(::grpc::ClientContext* context, const ::event_store::client::users::EnableReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::event_store::client::users::EnableResp>>(AsyncEnableRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::event_store::client::users::EnableResp>> PrepareAsyncEnable(::grpc::ClientContext* context, const ::event_store::client::users::EnableReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::event_store::client::users::EnableResp>>(PrepareAsyncEnableRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderInterface< ::event_store::client::users::DetailsResp>> Details(::grpc::ClientContext* context, const ::event_store::client::users::DetailsReq& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::event_store::client::users::DetailsResp>>(DetailsRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::event_store::client::users::DetailsResp>> AsyncDetails(::grpc::ClientContext* context, const ::event_store::client::users::DetailsReq& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::event_store::client::users::DetailsResp>>(AsyncDetailsRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::event_store::client::users::DetailsResp>> PrepareAsyncDetails(::grpc::ClientContext* context, const ::event_store::client::users::DetailsReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::event_store::client::users::DetailsResp>>(PrepareAsyncDetailsRaw(context, request, cq));
    }
    virtual ::grpc::Status ChangePassword(::grpc::ClientContext* context, const ::event_store::client::users::ChangePasswordReq& request, ::event_store::client::users::ChangePasswordResp* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::event_store::client::users::ChangePasswordResp>> AsyncChangePassword(::grpc::ClientContext* context, const ::event_store::client::users::ChangePasswordReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::event_store::client::users::ChangePasswordResp>>(AsyncChangePasswordRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::event_store::client::users::ChangePasswordResp>> PrepareAsyncChangePassword(::grpc::ClientContext* context, const ::event_store::client::users::ChangePasswordReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::event_store::client::users::ChangePasswordResp>>(PrepareAsyncChangePasswordRaw(context, request, cq));
    }
    virtual ::grpc::Status ResetPassword(::grpc::ClientContext* context, const ::event_store::client::users::ResetPasswordReq& request, ::event_store::client::users::ResetPasswordResp* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::event_store::client::users::ResetPasswordResp>> AsyncResetPassword(::grpc::ClientContext* context, const ::event_store::client::users::ResetPasswordReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::event_store::client::users::ResetPasswordResp>>(AsyncResetPasswordRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::event_store::client::users::ResetPasswordResp>> PrepareAsyncResetPassword(::grpc::ClientContext* context, const ::event_store::client::users::ResetPasswordReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::event_store::client::users::ResetPasswordResp>>(PrepareAsyncResetPasswordRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      virtual void Create(::grpc::ClientContext* context, const ::event_store::client::users::CreateReq* request, ::event_store::client::users::CreateResp* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Create(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::users::CreateResp* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Create(::grpc::ClientContext* context, const ::event_store::client::users::CreateReq* request, ::event_store::client::users::CreateResp* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Create(::grpc::ClientContext* context, const ::event_store::client::users::CreateReq* request, ::event_store::client::users::CreateResp* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Create(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::users::CreateResp* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Create(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::users::CreateResp* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void Update(::grpc::ClientContext* context, const ::event_store::client::users::UpdateReq* request, ::event_store::client::users::UpdateResp* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Update(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::users::UpdateResp* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Update(::grpc::ClientContext* context, const ::event_store::client::users::UpdateReq* request, ::event_store::client::users::UpdateResp* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Update(::grpc::ClientContext* context, const ::event_store::client::users::UpdateReq* request, ::event_store::client::users::UpdateResp* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Update(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::users::UpdateResp* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Update(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::users::UpdateResp* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void Delete(::grpc::ClientContext* context, const ::event_store::client::users::DeleteReq* request, ::event_store::client::users::DeleteResp* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Delete(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::users::DeleteResp* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Delete(::grpc::ClientContext* context, const ::event_store::client::users::DeleteReq* request, ::event_store::client::users::DeleteResp* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Delete(::grpc::ClientContext* context, const ::event_store::client::users::DeleteReq* request, ::event_store::client::users::DeleteResp* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Delete(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::users::DeleteResp* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Delete(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::users::DeleteResp* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void Disable(::grpc::ClientContext* context, const ::event_store::client::users::DisableReq* request, ::event_store::client::users::DisableResp* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Disable(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::users::DisableResp* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Disable(::grpc::ClientContext* context, const ::event_store::client::users::DisableReq* request, ::event_store::client::users::DisableResp* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Disable(::grpc::ClientContext* context, const ::event_store::client::users::DisableReq* request, ::event_store::client::users::DisableResp* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Disable(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::users::DisableResp* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Disable(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::users::DisableResp* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void Enable(::grpc::ClientContext* context, const ::event_store::client::users::EnableReq* request, ::event_store::client::users::EnableResp* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Enable(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::users::EnableResp* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Enable(::grpc::ClientContext* context, const ::event_store::client::users::EnableReq* request, ::event_store::client::users::EnableResp* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Enable(::grpc::ClientContext* context, const ::event_store::client::users::EnableReq* request, ::event_store::client::users::EnableResp* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Enable(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::users::EnableResp* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Enable(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::users::EnableResp* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Details(::grpc::ClientContext* context, ::event_store::client::users::DetailsReq* request, ::grpc::ClientReadReactor< ::event_store::client::users::DetailsResp>* reactor) = 0;
      #else
      virtual void Details(::grpc::ClientContext* context, ::event_store::client::users::DetailsReq* request, ::grpc::experimental::ClientReadReactor< ::event_store::client::users::DetailsResp>* reactor) = 0;
      #endif
      virtual void ChangePassword(::grpc::ClientContext* context, const ::event_store::client::users::ChangePasswordReq* request, ::event_store::client::users::ChangePasswordResp* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ChangePassword(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::users::ChangePasswordResp* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ChangePassword(::grpc::ClientContext* context, const ::event_store::client::users::ChangePasswordReq* request, ::event_store::client::users::ChangePasswordResp* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ChangePassword(::grpc::ClientContext* context, const ::event_store::client::users::ChangePasswordReq* request, ::event_store::client::users::ChangePasswordResp* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ChangePassword(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::users::ChangePasswordResp* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ChangePassword(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::users::ChangePasswordResp* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void ResetPassword(::grpc::ClientContext* context, const ::event_store::client::users::ResetPasswordReq* request, ::event_store::client::users::ResetPasswordResp* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ResetPassword(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::users::ResetPasswordResp* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ResetPassword(::grpc::ClientContext* context, const ::event_store::client::users::ResetPasswordReq* request, ::event_store::client::users::ResetPasswordResp* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ResetPassword(::grpc::ClientContext* context, const ::event_store::client::users::ResetPasswordReq* request, ::event_store::client::users::ResetPasswordResp* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ResetPassword(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::users::ResetPasswordResp* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ResetPassword(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::users::ResetPasswordResp* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::event_store::client::users::CreateResp>* AsyncCreateRaw(::grpc::ClientContext* context, const ::event_store::client::users::CreateReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::event_store::client::users::CreateResp>* PrepareAsyncCreateRaw(::grpc::ClientContext* context, const ::event_store::client::users::CreateReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::event_store::client::users::UpdateResp>* AsyncUpdateRaw(::grpc::ClientContext* context, const ::event_store::client::users::UpdateReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::event_store::client::users::UpdateResp>* PrepareAsyncUpdateRaw(::grpc::ClientContext* context, const ::event_store::client::users::UpdateReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::event_store::client::users::DeleteResp>* AsyncDeleteRaw(::grpc::ClientContext* context, const ::event_store::client::users::DeleteReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::event_store::client::users::DeleteResp>* PrepareAsyncDeleteRaw(::grpc::ClientContext* context, const ::event_store::client::users::DeleteReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::event_store::client::users::DisableResp>* AsyncDisableRaw(::grpc::ClientContext* context, const ::event_store::client::users::DisableReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::event_store::client::users::DisableResp>* PrepareAsyncDisableRaw(::grpc::ClientContext* context, const ::event_store::client::users::DisableReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::event_store::client::users::EnableResp>* AsyncEnableRaw(::grpc::ClientContext* context, const ::event_store::client::users::EnableReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::event_store::client::users::EnableResp>* PrepareAsyncEnableRaw(::grpc::ClientContext* context, const ::event_store::client::users::EnableReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::event_store::client::users::DetailsResp>* DetailsRaw(::grpc::ClientContext* context, const ::event_store::client::users::DetailsReq& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::event_store::client::users::DetailsResp>* AsyncDetailsRaw(::grpc::ClientContext* context, const ::event_store::client::users::DetailsReq& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::event_store::client::users::DetailsResp>* PrepareAsyncDetailsRaw(::grpc::ClientContext* context, const ::event_store::client::users::DetailsReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::event_store::client::users::ChangePasswordResp>* AsyncChangePasswordRaw(::grpc::ClientContext* context, const ::event_store::client::users::ChangePasswordReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::event_store::client::users::ChangePasswordResp>* PrepareAsyncChangePasswordRaw(::grpc::ClientContext* context, const ::event_store::client::users::ChangePasswordReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::event_store::client::users::ResetPasswordResp>* AsyncResetPasswordRaw(::grpc::ClientContext* context, const ::event_store::client::users::ResetPasswordReq& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::event_store::client::users::ResetPasswordResp>* PrepareAsyncResetPasswordRaw(::grpc::ClientContext* context, const ::event_store::client::users::ResetPasswordReq& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status Create(::grpc::ClientContext* context, const ::event_store::client::users::CreateReq& request, ::event_store::client::users::CreateResp* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::event_store::client::users::CreateResp>> AsyncCreate(::grpc::ClientContext* context, const ::event_store::client::users::CreateReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::event_store::client::users::CreateResp>>(AsyncCreateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::event_store::client::users::CreateResp>> PrepareAsyncCreate(::grpc::ClientContext* context, const ::event_store::client::users::CreateReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::event_store::client::users::CreateResp>>(PrepareAsyncCreateRaw(context, request, cq));
    }
    ::grpc::Status Update(::grpc::ClientContext* context, const ::event_store::client::users::UpdateReq& request, ::event_store::client::users::UpdateResp* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::event_store::client::users::UpdateResp>> AsyncUpdate(::grpc::ClientContext* context, const ::event_store::client::users::UpdateReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::event_store::client::users::UpdateResp>>(AsyncUpdateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::event_store::client::users::UpdateResp>> PrepareAsyncUpdate(::grpc::ClientContext* context, const ::event_store::client::users::UpdateReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::event_store::client::users::UpdateResp>>(PrepareAsyncUpdateRaw(context, request, cq));
    }
    ::grpc::Status Delete(::grpc::ClientContext* context, const ::event_store::client::users::DeleteReq& request, ::event_store::client::users::DeleteResp* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::event_store::client::users::DeleteResp>> AsyncDelete(::grpc::ClientContext* context, const ::event_store::client::users::DeleteReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::event_store::client::users::DeleteResp>>(AsyncDeleteRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::event_store::client::users::DeleteResp>> PrepareAsyncDelete(::grpc::ClientContext* context, const ::event_store::client::users::DeleteReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::event_store::client::users::DeleteResp>>(PrepareAsyncDeleteRaw(context, request, cq));
    }
    ::grpc::Status Disable(::grpc::ClientContext* context, const ::event_store::client::users::DisableReq& request, ::event_store::client::users::DisableResp* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::event_store::client::users::DisableResp>> AsyncDisable(::grpc::ClientContext* context, const ::event_store::client::users::DisableReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::event_store::client::users::DisableResp>>(AsyncDisableRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::event_store::client::users::DisableResp>> PrepareAsyncDisable(::grpc::ClientContext* context, const ::event_store::client::users::DisableReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::event_store::client::users::DisableResp>>(PrepareAsyncDisableRaw(context, request, cq));
    }
    ::grpc::Status Enable(::grpc::ClientContext* context, const ::event_store::client::users::EnableReq& request, ::event_store::client::users::EnableResp* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::event_store::client::users::EnableResp>> AsyncEnable(::grpc::ClientContext* context, const ::event_store::client::users::EnableReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::event_store::client::users::EnableResp>>(AsyncEnableRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::event_store::client::users::EnableResp>> PrepareAsyncEnable(::grpc::ClientContext* context, const ::event_store::client::users::EnableReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::event_store::client::users::EnableResp>>(PrepareAsyncEnableRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::event_store::client::users::DetailsResp>> Details(::grpc::ClientContext* context, const ::event_store::client::users::DetailsReq& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::event_store::client::users::DetailsResp>>(DetailsRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::event_store::client::users::DetailsResp>> AsyncDetails(::grpc::ClientContext* context, const ::event_store::client::users::DetailsReq& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::event_store::client::users::DetailsResp>>(AsyncDetailsRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::event_store::client::users::DetailsResp>> PrepareAsyncDetails(::grpc::ClientContext* context, const ::event_store::client::users::DetailsReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::event_store::client::users::DetailsResp>>(PrepareAsyncDetailsRaw(context, request, cq));
    }
    ::grpc::Status ChangePassword(::grpc::ClientContext* context, const ::event_store::client::users::ChangePasswordReq& request, ::event_store::client::users::ChangePasswordResp* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::event_store::client::users::ChangePasswordResp>> AsyncChangePassword(::grpc::ClientContext* context, const ::event_store::client::users::ChangePasswordReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::event_store::client::users::ChangePasswordResp>>(AsyncChangePasswordRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::event_store::client::users::ChangePasswordResp>> PrepareAsyncChangePassword(::grpc::ClientContext* context, const ::event_store::client::users::ChangePasswordReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::event_store::client::users::ChangePasswordResp>>(PrepareAsyncChangePasswordRaw(context, request, cq));
    }
    ::grpc::Status ResetPassword(::grpc::ClientContext* context, const ::event_store::client::users::ResetPasswordReq& request, ::event_store::client::users::ResetPasswordResp* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::event_store::client::users::ResetPasswordResp>> AsyncResetPassword(::grpc::ClientContext* context, const ::event_store::client::users::ResetPasswordReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::event_store::client::users::ResetPasswordResp>>(AsyncResetPasswordRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::event_store::client::users::ResetPasswordResp>> PrepareAsyncResetPassword(::grpc::ClientContext* context, const ::event_store::client::users::ResetPasswordReq& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::event_store::client::users::ResetPasswordResp>>(PrepareAsyncResetPasswordRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void Create(::grpc::ClientContext* context, const ::event_store::client::users::CreateReq* request, ::event_store::client::users::CreateResp* response, std::function<void(::grpc::Status)>) override;
      void Create(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::users::CreateResp* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Create(::grpc::ClientContext* context, const ::event_store::client::users::CreateReq* request, ::event_store::client::users::CreateResp* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Create(::grpc::ClientContext* context, const ::event_store::client::users::CreateReq* request, ::event_store::client::users::CreateResp* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Create(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::users::CreateResp* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Create(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::users::CreateResp* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void Update(::grpc::ClientContext* context, const ::event_store::client::users::UpdateReq* request, ::event_store::client::users::UpdateResp* response, std::function<void(::grpc::Status)>) override;
      void Update(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::users::UpdateResp* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Update(::grpc::ClientContext* context, const ::event_store::client::users::UpdateReq* request, ::event_store::client::users::UpdateResp* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Update(::grpc::ClientContext* context, const ::event_store::client::users::UpdateReq* request, ::event_store::client::users::UpdateResp* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Update(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::users::UpdateResp* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Update(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::users::UpdateResp* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void Delete(::grpc::ClientContext* context, const ::event_store::client::users::DeleteReq* request, ::event_store::client::users::DeleteResp* response, std::function<void(::grpc::Status)>) override;
      void Delete(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::users::DeleteResp* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Delete(::grpc::ClientContext* context, const ::event_store::client::users::DeleteReq* request, ::event_store::client::users::DeleteResp* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Delete(::grpc::ClientContext* context, const ::event_store::client::users::DeleteReq* request, ::event_store::client::users::DeleteResp* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Delete(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::users::DeleteResp* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Delete(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::users::DeleteResp* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void Disable(::grpc::ClientContext* context, const ::event_store::client::users::DisableReq* request, ::event_store::client::users::DisableResp* response, std::function<void(::grpc::Status)>) override;
      void Disable(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::users::DisableResp* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Disable(::grpc::ClientContext* context, const ::event_store::client::users::DisableReq* request, ::event_store::client::users::DisableResp* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Disable(::grpc::ClientContext* context, const ::event_store::client::users::DisableReq* request, ::event_store::client::users::DisableResp* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Disable(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::users::DisableResp* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Disable(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::users::DisableResp* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void Enable(::grpc::ClientContext* context, const ::event_store::client::users::EnableReq* request, ::event_store::client::users::EnableResp* response, std::function<void(::grpc::Status)>) override;
      void Enable(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::users::EnableResp* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Enable(::grpc::ClientContext* context, const ::event_store::client::users::EnableReq* request, ::event_store::client::users::EnableResp* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Enable(::grpc::ClientContext* context, const ::event_store::client::users::EnableReq* request, ::event_store::client::users::EnableResp* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Enable(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::users::EnableResp* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Enable(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::users::EnableResp* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Details(::grpc::ClientContext* context, ::event_store::client::users::DetailsReq* request, ::grpc::ClientReadReactor< ::event_store::client::users::DetailsResp>* reactor) override;
      #else
      void Details(::grpc::ClientContext* context, ::event_store::client::users::DetailsReq* request, ::grpc::experimental::ClientReadReactor< ::event_store::client::users::DetailsResp>* reactor) override;
      #endif
      void ChangePassword(::grpc::ClientContext* context, const ::event_store::client::users::ChangePasswordReq* request, ::event_store::client::users::ChangePasswordResp* response, std::function<void(::grpc::Status)>) override;
      void ChangePassword(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::users::ChangePasswordResp* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ChangePassword(::grpc::ClientContext* context, const ::event_store::client::users::ChangePasswordReq* request, ::event_store::client::users::ChangePasswordResp* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ChangePassword(::grpc::ClientContext* context, const ::event_store::client::users::ChangePasswordReq* request, ::event_store::client::users::ChangePasswordResp* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ChangePassword(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::users::ChangePasswordResp* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ChangePassword(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::users::ChangePasswordResp* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ResetPassword(::grpc::ClientContext* context, const ::event_store::client::users::ResetPasswordReq* request, ::event_store::client::users::ResetPasswordResp* response, std::function<void(::grpc::Status)>) override;
      void ResetPassword(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::users::ResetPasswordResp* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ResetPassword(::grpc::ClientContext* context, const ::event_store::client::users::ResetPasswordReq* request, ::event_store::client::users::ResetPasswordResp* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ResetPassword(::grpc::ClientContext* context, const ::event_store::client::users::ResetPasswordReq* request, ::event_store::client::users::ResetPasswordResp* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ResetPassword(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::users::ResetPasswordResp* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ResetPassword(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::users::ResetPasswordResp* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::event_store::client::users::CreateResp>* AsyncCreateRaw(::grpc::ClientContext* context, const ::event_store::client::users::CreateReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::event_store::client::users::CreateResp>* PrepareAsyncCreateRaw(::grpc::ClientContext* context, const ::event_store::client::users::CreateReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::event_store::client::users::UpdateResp>* AsyncUpdateRaw(::grpc::ClientContext* context, const ::event_store::client::users::UpdateReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::event_store::client::users::UpdateResp>* PrepareAsyncUpdateRaw(::grpc::ClientContext* context, const ::event_store::client::users::UpdateReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::event_store::client::users::DeleteResp>* AsyncDeleteRaw(::grpc::ClientContext* context, const ::event_store::client::users::DeleteReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::event_store::client::users::DeleteResp>* PrepareAsyncDeleteRaw(::grpc::ClientContext* context, const ::event_store::client::users::DeleteReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::event_store::client::users::DisableResp>* AsyncDisableRaw(::grpc::ClientContext* context, const ::event_store::client::users::DisableReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::event_store::client::users::DisableResp>* PrepareAsyncDisableRaw(::grpc::ClientContext* context, const ::event_store::client::users::DisableReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::event_store::client::users::EnableResp>* AsyncEnableRaw(::grpc::ClientContext* context, const ::event_store::client::users::EnableReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::event_store::client::users::EnableResp>* PrepareAsyncEnableRaw(::grpc::ClientContext* context, const ::event_store::client::users::EnableReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::event_store::client::users::DetailsResp>* DetailsRaw(::grpc::ClientContext* context, const ::event_store::client::users::DetailsReq& request) override;
    ::grpc::ClientAsyncReader< ::event_store::client::users::DetailsResp>* AsyncDetailsRaw(::grpc::ClientContext* context, const ::event_store::client::users::DetailsReq& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::event_store::client::users::DetailsResp>* PrepareAsyncDetailsRaw(::grpc::ClientContext* context, const ::event_store::client::users::DetailsReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::event_store::client::users::ChangePasswordResp>* AsyncChangePasswordRaw(::grpc::ClientContext* context, const ::event_store::client::users::ChangePasswordReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::event_store::client::users::ChangePasswordResp>* PrepareAsyncChangePasswordRaw(::grpc::ClientContext* context, const ::event_store::client::users::ChangePasswordReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::event_store::client::users::ResetPasswordResp>* AsyncResetPasswordRaw(::grpc::ClientContext* context, const ::event_store::client::users::ResetPasswordReq& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::event_store::client::users::ResetPasswordResp>* PrepareAsyncResetPasswordRaw(::grpc::ClientContext* context, const ::event_store::client::users::ResetPasswordReq& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_Create_;
    const ::grpc::internal::RpcMethod rpcmethod_Update_;
    const ::grpc::internal::RpcMethod rpcmethod_Delete_;
    const ::grpc::internal::RpcMethod rpcmethod_Disable_;
    const ::grpc::internal::RpcMethod rpcmethod_Enable_;
    const ::grpc::internal::RpcMethod rpcmethod_Details_;
    const ::grpc::internal::RpcMethod rpcmethod_ChangePassword_;
    const ::grpc::internal::RpcMethod rpcmethod_ResetPassword_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status Create(::grpc::ServerContext* context, const ::event_store::client::users::CreateReq* request, ::event_store::client::users::CreateResp* response);
    virtual ::grpc::Status Update(::grpc::ServerContext* context, const ::event_store::client::users::UpdateReq* request, ::event_store::client::users::UpdateResp* response);
    virtual ::grpc::Status Delete(::grpc::ServerContext* context, const ::event_store::client::users::DeleteReq* request, ::event_store::client::users::DeleteResp* response);
    virtual ::grpc::Status Disable(::grpc::ServerContext* context, const ::event_store::client::users::DisableReq* request, ::event_store::client::users::DisableResp* response);
    virtual ::grpc::Status Enable(::grpc::ServerContext* context, const ::event_store::client::users::EnableReq* request, ::event_store::client::users::EnableResp* response);
    virtual ::grpc::Status Details(::grpc::ServerContext* context, const ::event_store::client::users::DetailsReq* request, ::grpc::ServerWriter< ::event_store::client::users::DetailsResp>* writer);
    virtual ::grpc::Status ChangePassword(::grpc::ServerContext* context, const ::event_store::client::users::ChangePasswordReq* request, ::event_store::client::users::ChangePasswordResp* response);
    virtual ::grpc::Status ResetPassword(::grpc::ServerContext* context, const ::event_store::client::users::ResetPasswordReq* request, ::event_store::client::users::ResetPasswordResp* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_Create : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Create() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_Create() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Create(::grpc::ServerContext* /*context*/, const ::event_store::client::users::CreateReq* /*request*/, ::event_store::client::users::CreateResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreate(::grpc::ServerContext* context, ::event_store::client::users::CreateReq* request, ::grpc::ServerAsyncResponseWriter< ::event_store::client::users::CreateResp>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Update : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Update() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_Update() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Update(::grpc::ServerContext* /*context*/, const ::event_store::client::users::UpdateReq* /*request*/, ::event_store::client::users::UpdateResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdate(::grpc::ServerContext* context, ::event_store::client::users::UpdateReq* request, ::grpc::ServerAsyncResponseWriter< ::event_store::client::users::UpdateResp>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Delete : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Delete() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_Delete() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Delete(::grpc::ServerContext* /*context*/, const ::event_store::client::users::DeleteReq* /*request*/, ::event_store::client::users::DeleteResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDelete(::grpc::ServerContext* context, ::event_store::client::users::DeleteReq* request, ::grpc::ServerAsyncResponseWriter< ::event_store::client::users::DeleteResp>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Disable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Disable() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_Disable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Disable(::grpc::ServerContext* /*context*/, const ::event_store::client::users::DisableReq* /*request*/, ::event_store::client::users::DisableResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDisable(::grpc::ServerContext* context, ::event_store::client::users::DisableReq* request, ::grpc::ServerAsyncResponseWriter< ::event_store::client::users::DisableResp>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Enable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Enable() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_Enable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Enable(::grpc::ServerContext* /*context*/, const ::event_store::client::users::EnableReq* /*request*/, ::event_store::client::users::EnableResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestEnable(::grpc::ServerContext* context, ::event_store::client::users::EnableReq* request, ::grpc::ServerAsyncResponseWriter< ::event_store::client::users::EnableResp>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Details : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Details() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_Details() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Details(::grpc::ServerContext* /*context*/, const ::event_store::client::users::DetailsReq* /*request*/, ::grpc::ServerWriter< ::event_store::client::users::DetailsResp>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDetails(::grpc::ServerContext* context, ::event_store::client::users::DetailsReq* request, ::grpc::ServerAsyncWriter< ::event_store::client::users::DetailsResp>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(5, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ChangePassword : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ChangePassword() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_ChangePassword() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ChangePassword(::grpc::ServerContext* /*context*/, const ::event_store::client::users::ChangePasswordReq* /*request*/, ::event_store::client::users::ChangePasswordResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestChangePassword(::grpc::ServerContext* context, ::event_store::client::users::ChangePasswordReq* request, ::grpc::ServerAsyncResponseWriter< ::event_store::client::users::ChangePasswordResp>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ResetPassword : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ResetPassword() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_ResetPassword() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResetPassword(::grpc::ServerContext* /*context*/, const ::event_store::client::users::ResetPasswordReq* /*request*/, ::event_store::client::users::ResetPasswordResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestResetPassword(::grpc::ServerContext* context, ::event_store::client::users::ResetPasswordReq* request, ::grpc::ServerAsyncResponseWriter< ::event_store::client::users::ResetPasswordResp>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_Create<WithAsyncMethod_Update<WithAsyncMethod_Delete<WithAsyncMethod_Disable<WithAsyncMethod_Enable<WithAsyncMethod_Details<WithAsyncMethod_ChangePassword<WithAsyncMethod_ResetPassword<Service > > > > > > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Create : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Create() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(0,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::event_store::client::users::CreateReq, ::event_store::client::users::CreateResp>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::event_store::client::users::CreateReq* request, ::event_store::client::users::CreateResp* response) { return this->Create(context, request, response); }));}
    void SetMessageAllocatorFor_Create(
        ::grpc::experimental::MessageAllocator< ::event_store::client::users::CreateReq, ::event_store::client::users::CreateResp>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(0);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::event_store::client::users::CreateReq, ::event_store::client::users::CreateResp>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Create() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Create(::grpc::ServerContext* /*context*/, const ::event_store::client::users::CreateReq* /*request*/, ::event_store::client::users::CreateResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Create(
      ::grpc::CallbackServerContext* /*context*/, const ::event_store::client::users::CreateReq* /*request*/, ::event_store::client::users::CreateResp* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Create(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::event_store::client::users::CreateReq* /*request*/, ::event_store::client::users::CreateResp* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Update : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Update() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(1,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::event_store::client::users::UpdateReq, ::event_store::client::users::UpdateResp>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::event_store::client::users::UpdateReq* request, ::event_store::client::users::UpdateResp* response) { return this->Update(context, request, response); }));}
    void SetMessageAllocatorFor_Update(
        ::grpc::experimental::MessageAllocator< ::event_store::client::users::UpdateReq, ::event_store::client::users::UpdateResp>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(1);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::event_store::client::users::UpdateReq, ::event_store::client::users::UpdateResp>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Update() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Update(::grpc::ServerContext* /*context*/, const ::event_store::client::users::UpdateReq* /*request*/, ::event_store::client::users::UpdateResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Update(
      ::grpc::CallbackServerContext* /*context*/, const ::event_store::client::users::UpdateReq* /*request*/, ::event_store::client::users::UpdateResp* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Update(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::event_store::client::users::UpdateReq* /*request*/, ::event_store::client::users::UpdateResp* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Delete : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Delete() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(2,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::event_store::client::users::DeleteReq, ::event_store::client::users::DeleteResp>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::event_store::client::users::DeleteReq* request, ::event_store::client::users::DeleteResp* response) { return this->Delete(context, request, response); }));}
    void SetMessageAllocatorFor_Delete(
        ::grpc::experimental::MessageAllocator< ::event_store::client::users::DeleteReq, ::event_store::client::users::DeleteResp>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(2);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::event_store::client::users::DeleteReq, ::event_store::client::users::DeleteResp>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Delete() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Delete(::grpc::ServerContext* /*context*/, const ::event_store::client::users::DeleteReq* /*request*/, ::event_store::client::users::DeleteResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Delete(
      ::grpc::CallbackServerContext* /*context*/, const ::event_store::client::users::DeleteReq* /*request*/, ::event_store::client::users::DeleteResp* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Delete(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::event_store::client::users::DeleteReq* /*request*/, ::event_store::client::users::DeleteResp* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Disable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Disable() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(3,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::event_store::client::users::DisableReq, ::event_store::client::users::DisableResp>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::event_store::client::users::DisableReq* request, ::event_store::client::users::DisableResp* response) { return this->Disable(context, request, response); }));}
    void SetMessageAllocatorFor_Disable(
        ::grpc::experimental::MessageAllocator< ::event_store::client::users::DisableReq, ::event_store::client::users::DisableResp>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(3);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::event_store::client::users::DisableReq, ::event_store::client::users::DisableResp>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Disable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Disable(::grpc::ServerContext* /*context*/, const ::event_store::client::users::DisableReq* /*request*/, ::event_store::client::users::DisableResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Disable(
      ::grpc::CallbackServerContext* /*context*/, const ::event_store::client::users::DisableReq* /*request*/, ::event_store::client::users::DisableResp* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Disable(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::event_store::client::users::DisableReq* /*request*/, ::event_store::client::users::DisableResp* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Enable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Enable() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(4,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::event_store::client::users::EnableReq, ::event_store::client::users::EnableResp>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::event_store::client::users::EnableReq* request, ::event_store::client::users::EnableResp* response) { return this->Enable(context, request, response); }));}
    void SetMessageAllocatorFor_Enable(
        ::grpc::experimental::MessageAllocator< ::event_store::client::users::EnableReq, ::event_store::client::users::EnableResp>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(4);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::event_store::client::users::EnableReq, ::event_store::client::users::EnableResp>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Enable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Enable(::grpc::ServerContext* /*context*/, const ::event_store::client::users::EnableReq* /*request*/, ::event_store::client::users::EnableResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Enable(
      ::grpc::CallbackServerContext* /*context*/, const ::event_store::client::users::EnableReq* /*request*/, ::event_store::client::users::EnableResp* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Enable(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::event_store::client::users::EnableReq* /*request*/, ::event_store::client::users::EnableResp* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Details : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Details() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(5,
          new ::grpc_impl::internal::CallbackServerStreamingHandler< ::event_store::client::users::DetailsReq, ::event_store::client::users::DetailsResp>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::event_store::client::users::DetailsReq* request) { return this->Details(context, request); }));
    }
    ~ExperimentalWithCallbackMethod_Details() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Details(::grpc::ServerContext* /*context*/, const ::event_store::client::users::DetailsReq* /*request*/, ::grpc::ServerWriter< ::event_store::client::users::DetailsResp>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::event_store::client::users::DetailsResp>* Details(
      ::grpc::CallbackServerContext* /*context*/, const ::event_store::client::users::DetailsReq* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::event_store::client::users::DetailsResp>* Details(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::event_store::client::users::DetailsReq* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ChangePassword : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ChangePassword() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(6,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::event_store::client::users::ChangePasswordReq, ::event_store::client::users::ChangePasswordResp>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::event_store::client::users::ChangePasswordReq* request, ::event_store::client::users::ChangePasswordResp* response) { return this->ChangePassword(context, request, response); }));}
    void SetMessageAllocatorFor_ChangePassword(
        ::grpc::experimental::MessageAllocator< ::event_store::client::users::ChangePasswordReq, ::event_store::client::users::ChangePasswordResp>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(6);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::event_store::client::users::ChangePasswordReq, ::event_store::client::users::ChangePasswordResp>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ChangePassword() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ChangePassword(::grpc::ServerContext* /*context*/, const ::event_store::client::users::ChangePasswordReq* /*request*/, ::event_store::client::users::ChangePasswordResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ChangePassword(
      ::grpc::CallbackServerContext* /*context*/, const ::event_store::client::users::ChangePasswordReq* /*request*/, ::event_store::client::users::ChangePasswordResp* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ChangePassword(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::event_store::client::users::ChangePasswordReq* /*request*/, ::event_store::client::users::ChangePasswordResp* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ResetPassword : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ResetPassword() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(7,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::event_store::client::users::ResetPasswordReq, ::event_store::client::users::ResetPasswordResp>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::event_store::client::users::ResetPasswordReq* request, ::event_store::client::users::ResetPasswordResp* response) { return this->ResetPassword(context, request, response); }));}
    void SetMessageAllocatorFor_ResetPassword(
        ::grpc::experimental::MessageAllocator< ::event_store::client::users::ResetPasswordReq, ::event_store::client::users::ResetPasswordResp>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(7);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::event_store::client::users::ResetPasswordReq, ::event_store::client::users::ResetPasswordResp>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ResetPassword() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResetPassword(::grpc::ServerContext* /*context*/, const ::event_store::client::users::ResetPasswordReq* /*request*/, ::event_store::client::users::ResetPasswordResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ResetPassword(
      ::grpc::CallbackServerContext* /*context*/, const ::event_store::client::users::ResetPasswordReq* /*request*/, ::event_store::client::users::ResetPasswordResp* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ResetPassword(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::event_store::client::users::ResetPasswordReq* /*request*/, ::event_store::client::users::ResetPasswordResp* /*response*/)
    #endif
      { return nullptr; }
  };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef ExperimentalWithCallbackMethod_Create<ExperimentalWithCallbackMethod_Update<ExperimentalWithCallbackMethod_Delete<ExperimentalWithCallbackMethod_Disable<ExperimentalWithCallbackMethod_Enable<ExperimentalWithCallbackMethod_Details<ExperimentalWithCallbackMethod_ChangePassword<ExperimentalWithCallbackMethod_ResetPassword<Service > > > > > > > > CallbackService;
  #endif

  typedef ExperimentalWithCallbackMethod_Create<ExperimentalWithCallbackMethod_Update<ExperimentalWithCallbackMethod_Delete<ExperimentalWithCallbackMethod_Disable<ExperimentalWithCallbackMethod_Enable<ExperimentalWithCallbackMethod_Details<ExperimentalWithCallbackMethod_ChangePassword<ExperimentalWithCallbackMethod_ResetPassword<Service > > > > > > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_Create : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Create() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_Create() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Create(::grpc::ServerContext* /*context*/, const ::event_store::client::users::CreateReq* /*request*/, ::event_store::client::users::CreateResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Update : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Update() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_Update() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Update(::grpc::ServerContext* /*context*/, const ::event_store::client::users::UpdateReq* /*request*/, ::event_store::client::users::UpdateResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Delete : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Delete() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_Delete() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Delete(::grpc::ServerContext* /*context*/, const ::event_store::client::users::DeleteReq* /*request*/, ::event_store::client::users::DeleteResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Disable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Disable() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_Disable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Disable(::grpc::ServerContext* /*context*/, const ::event_store::client::users::DisableReq* /*request*/, ::event_store::client::users::DisableResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Enable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Enable() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_Enable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Enable(::grpc::ServerContext* /*context*/, const ::event_store::client::users::EnableReq* /*request*/, ::event_store::client::users::EnableResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Details : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Details() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_Details() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Details(::grpc::ServerContext* /*context*/, const ::event_store::client::users::DetailsReq* /*request*/, ::grpc::ServerWriter< ::event_store::client::users::DetailsResp>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ChangePassword : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ChangePassword() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_ChangePassword() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ChangePassword(::grpc::ServerContext* /*context*/, const ::event_store::client::users::ChangePasswordReq* /*request*/, ::event_store::client::users::ChangePasswordResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ResetPassword : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ResetPassword() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_ResetPassword() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResetPassword(::grpc::ServerContext* /*context*/, const ::event_store::client::users::ResetPasswordReq* /*request*/, ::event_store::client::users::ResetPasswordResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_Create : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Create() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_Create() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Create(::grpc::ServerContext* /*context*/, const ::event_store::client::users::CreateReq* /*request*/, ::event_store::client::users::CreateResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreate(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Update : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Update() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_Update() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Update(::grpc::ServerContext* /*context*/, const ::event_store::client::users::UpdateReq* /*request*/, ::event_store::client::users::UpdateResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdate(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Delete : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Delete() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_Delete() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Delete(::grpc::ServerContext* /*context*/, const ::event_store::client::users::DeleteReq* /*request*/, ::event_store::client::users::DeleteResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDelete(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Disable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Disable() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_Disable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Disable(::grpc::ServerContext* /*context*/, const ::event_store::client::users::DisableReq* /*request*/, ::event_store::client::users::DisableResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDisable(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Enable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Enable() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_Enable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Enable(::grpc::ServerContext* /*context*/, const ::event_store::client::users::EnableReq* /*request*/, ::event_store::client::users::EnableResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestEnable(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Details : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Details() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_Details() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Details(::grpc::ServerContext* /*context*/, const ::event_store::client::users::DetailsReq* /*request*/, ::grpc::ServerWriter< ::event_store::client::users::DetailsResp>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDetails(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(5, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ChangePassword : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ChangePassword() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_ChangePassword() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ChangePassword(::grpc::ServerContext* /*context*/, const ::event_store::client::users::ChangePasswordReq* /*request*/, ::event_store::client::users::ChangePasswordResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestChangePassword(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ResetPassword : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ResetPassword() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_ResetPassword() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResetPassword(::grpc::ServerContext* /*context*/, const ::event_store::client::users::ResetPasswordReq* /*request*/, ::event_store::client::users::ResetPasswordResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestResetPassword(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Create : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Create() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(0,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Create(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_Create() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Create(::grpc::ServerContext* /*context*/, const ::event_store::client::users::CreateReq* /*request*/, ::event_store::client::users::CreateResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Create(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Create(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Update : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Update() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(1,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Update(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_Update() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Update(::grpc::ServerContext* /*context*/, const ::event_store::client::users::UpdateReq* /*request*/, ::event_store::client::users::UpdateResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Update(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Update(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Delete : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Delete() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(2,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Delete(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_Delete() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Delete(::grpc::ServerContext* /*context*/, const ::event_store::client::users::DeleteReq* /*request*/, ::event_store::client::users::DeleteResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Delete(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Delete(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Disable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Disable() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(3,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Disable(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_Disable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Disable(::grpc::ServerContext* /*context*/, const ::event_store::client::users::DisableReq* /*request*/, ::event_store::client::users::DisableResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Disable(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Disable(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Enable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Enable() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(4,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Enable(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_Enable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Enable(::grpc::ServerContext* /*context*/, const ::event_store::client::users::EnableReq* /*request*/, ::event_store::client::users::EnableResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Enable(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Enable(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Details : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Details() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(5,
          new ::grpc_impl::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const::grpc::ByteBuffer* request) { return this->Details(context, request); }));
    }
    ~ExperimentalWithRawCallbackMethod_Details() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Details(::grpc::ServerContext* /*context*/, const ::event_store::client::users::DetailsReq* /*request*/, ::grpc::ServerWriter< ::event_store::client::users::DetailsResp>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* Details(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #else
    virtual ::grpc::experimental::ServerWriteReactor< ::grpc::ByteBuffer>* Details(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ChangePassword : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ChangePassword() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(6,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ChangePassword(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ChangePassword() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ChangePassword(::grpc::ServerContext* /*context*/, const ::event_store::client::users::ChangePasswordReq* /*request*/, ::event_store::client::users::ChangePasswordResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ChangePassword(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ChangePassword(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ResetPassword : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ResetPassword() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(7,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ResetPassword(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ResetPassword() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResetPassword(::grpc::ServerContext* /*context*/, const ::event_store::client::users::ResetPasswordReq* /*request*/, ::event_store::client::users::ResetPasswordResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ResetPassword(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ResetPassword(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Create : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Create() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::event_store::client::users::CreateReq, ::event_store::client::users::CreateResp>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::event_store::client::users::CreateReq, ::event_store::client::users::CreateResp>* streamer) {
                       return this->StreamedCreate(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Create() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Create(::grpc::ServerContext* /*context*/, const ::event_store::client::users::CreateReq* /*request*/, ::event_store::client::users::CreateResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCreate(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::event_store::client::users::CreateReq,::event_store::client::users::CreateResp>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Update : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Update() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::event_store::client::users::UpdateReq, ::event_store::client::users::UpdateResp>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::event_store::client::users::UpdateReq, ::event_store::client::users::UpdateResp>* streamer) {
                       return this->StreamedUpdate(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Update() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Update(::grpc::ServerContext* /*context*/, const ::event_store::client::users::UpdateReq* /*request*/, ::event_store::client::users::UpdateResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUpdate(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::event_store::client::users::UpdateReq,::event_store::client::users::UpdateResp>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Delete : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Delete() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::event_store::client::users::DeleteReq, ::event_store::client::users::DeleteResp>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::event_store::client::users::DeleteReq, ::event_store::client::users::DeleteResp>* streamer) {
                       return this->StreamedDelete(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Delete() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Delete(::grpc::ServerContext* /*context*/, const ::event_store::client::users::DeleteReq* /*request*/, ::event_store::client::users::DeleteResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDelete(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::event_store::client::users::DeleteReq,::event_store::client::users::DeleteResp>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Disable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Disable() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::event_store::client::users::DisableReq, ::event_store::client::users::DisableResp>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::event_store::client::users::DisableReq, ::event_store::client::users::DisableResp>* streamer) {
                       return this->StreamedDisable(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Disable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Disable(::grpc::ServerContext* /*context*/, const ::event_store::client::users::DisableReq* /*request*/, ::event_store::client::users::DisableResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDisable(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::event_store::client::users::DisableReq,::event_store::client::users::DisableResp>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Enable : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Enable() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::event_store::client::users::EnableReq, ::event_store::client::users::EnableResp>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::event_store::client::users::EnableReq, ::event_store::client::users::EnableResp>* streamer) {
                       return this->StreamedEnable(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Enable() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Enable(::grpc::ServerContext* /*context*/, const ::event_store::client::users::EnableReq* /*request*/, ::event_store::client::users::EnableResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedEnable(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::event_store::client::users::EnableReq,::event_store::client::users::EnableResp>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ChangePassword : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ChangePassword() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::event_store::client::users::ChangePasswordReq, ::event_store::client::users::ChangePasswordResp>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::event_store::client::users::ChangePasswordReq, ::event_store::client::users::ChangePasswordResp>* streamer) {
                       return this->StreamedChangePassword(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ChangePassword() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ChangePassword(::grpc::ServerContext* /*context*/, const ::event_store::client::users::ChangePasswordReq* /*request*/, ::event_store::client::users::ChangePasswordResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedChangePassword(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::event_store::client::users::ChangePasswordReq,::event_store::client::users::ChangePasswordResp>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ResetPassword : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ResetPassword() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::event_store::client::users::ResetPasswordReq, ::event_store::client::users::ResetPasswordResp>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::event_store::client::users::ResetPasswordReq, ::event_store::client::users::ResetPasswordResp>* streamer) {
                       return this->StreamedResetPassword(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ResetPassword() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ResetPassword(::grpc::ServerContext* /*context*/, const ::event_store::client::users::ResetPasswordReq* /*request*/, ::event_store::client::users::ResetPasswordResp* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedResetPassword(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::event_store::client::users::ResetPasswordReq,::event_store::client::users::ResetPasswordResp>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_Create<WithStreamedUnaryMethod_Update<WithStreamedUnaryMethod_Delete<WithStreamedUnaryMethod_Disable<WithStreamedUnaryMethod_Enable<WithStreamedUnaryMethod_ChangePassword<WithStreamedUnaryMethod_ResetPassword<Service > > > > > > > StreamedUnaryService;
  template <class BaseClass>
  class WithSplitStreamingMethod_Details : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_Details() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::event_store::client::users::DetailsReq, ::event_store::client::users::DetailsResp>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerSplitStreamer<
                     ::event_store::client::users::DetailsReq, ::event_store::client::users::DetailsResp>* streamer) {
                       return this->StreamedDetails(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_Details() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Details(::grpc::ServerContext* /*context*/, const ::event_store::client::users::DetailsReq* /*request*/, ::grpc::ServerWriter< ::event_store::client::users::DetailsResp>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedDetails(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::event_store::client::users::DetailsReq,::event_store::client::users::DetailsResp>* server_split_streamer) = 0;
  };
  typedef WithSplitStreamingMethod_Details<Service > SplitStreamedService;
  typedef WithStreamedUnaryMethod_Create<WithStreamedUnaryMethod_Update<WithStreamedUnaryMethod_Delete<WithStreamedUnaryMethod_Disable<WithStreamedUnaryMethod_Enable<WithSplitStreamingMethod_Details<WithStreamedUnaryMethod_ChangePassword<WithStreamedUnaryMethod_ResetPassword<Service > > > > > > > > StreamedService;
};

}  // namespace users
}  // namespace client
}  // namespace event_store


#endif  // GRPC_users_2eproto__INCLUDED
