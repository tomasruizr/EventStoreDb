// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: cluster.proto
#ifndef GRPC_cluster_2eproto__INCLUDED
#define GRPC_cluster_2eproto__INCLUDED

#include "cluster.pb.h"

#include <functional>
#include <grpc/impl/codegen/port_platform.h>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace event_store {
namespace cluster {

class Gossip final {
 public:
  static constexpr char const* service_full_name() {
    return "event_store.cluster.Gossip";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status Update(::grpc::ClientContext* context, const ::event_store::cluster::GossipRequest& request, ::event_store::cluster::ClusterInfo* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::event_store::cluster::ClusterInfo>> AsyncUpdate(::grpc::ClientContext* context, const ::event_store::cluster::GossipRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::event_store::cluster::ClusterInfo>>(AsyncUpdateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::event_store::cluster::ClusterInfo>> PrepareAsyncUpdate(::grpc::ClientContext* context, const ::event_store::cluster::GossipRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::event_store::cluster::ClusterInfo>>(PrepareAsyncUpdateRaw(context, request, cq));
    }
    virtual ::grpc::Status Read(::grpc::ClientContext* context, const ::event_store::client::Empty& request, ::event_store::cluster::ClusterInfo* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::event_store::cluster::ClusterInfo>> AsyncRead(::grpc::ClientContext* context, const ::event_store::client::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::event_store::cluster::ClusterInfo>>(AsyncReadRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::event_store::cluster::ClusterInfo>> PrepareAsyncRead(::grpc::ClientContext* context, const ::event_store::client::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::event_store::cluster::ClusterInfo>>(PrepareAsyncReadRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      virtual void Update(::grpc::ClientContext* context, const ::event_store::cluster::GossipRequest* request, ::event_store::cluster::ClusterInfo* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Update(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::cluster::ClusterInfo* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Update(::grpc::ClientContext* context, const ::event_store::cluster::GossipRequest* request, ::event_store::cluster::ClusterInfo* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Update(::grpc::ClientContext* context, const ::event_store::cluster::GossipRequest* request, ::event_store::cluster::ClusterInfo* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Update(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::cluster::ClusterInfo* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Update(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::cluster::ClusterInfo* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void Read(::grpc::ClientContext* context, const ::event_store::client::Empty* request, ::event_store::cluster::ClusterInfo* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Read(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::cluster::ClusterInfo* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Read(::grpc::ClientContext* context, const ::event_store::client::Empty* request, ::event_store::cluster::ClusterInfo* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Read(::grpc::ClientContext* context, const ::event_store::client::Empty* request, ::event_store::cluster::ClusterInfo* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Read(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::cluster::ClusterInfo* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Read(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::cluster::ClusterInfo* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::event_store::cluster::ClusterInfo>* AsyncUpdateRaw(::grpc::ClientContext* context, const ::event_store::cluster::GossipRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::event_store::cluster::ClusterInfo>* PrepareAsyncUpdateRaw(::grpc::ClientContext* context, const ::event_store::cluster::GossipRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::event_store::cluster::ClusterInfo>* AsyncReadRaw(::grpc::ClientContext* context, const ::event_store::client::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::event_store::cluster::ClusterInfo>* PrepareAsyncReadRaw(::grpc::ClientContext* context, const ::event_store::client::Empty& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status Update(::grpc::ClientContext* context, const ::event_store::cluster::GossipRequest& request, ::event_store::cluster::ClusterInfo* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::event_store::cluster::ClusterInfo>> AsyncUpdate(::grpc::ClientContext* context, const ::event_store::cluster::GossipRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::event_store::cluster::ClusterInfo>>(AsyncUpdateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::event_store::cluster::ClusterInfo>> PrepareAsyncUpdate(::grpc::ClientContext* context, const ::event_store::cluster::GossipRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::event_store::cluster::ClusterInfo>>(PrepareAsyncUpdateRaw(context, request, cq));
    }
    ::grpc::Status Read(::grpc::ClientContext* context, const ::event_store::client::Empty& request, ::event_store::cluster::ClusterInfo* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::event_store::cluster::ClusterInfo>> AsyncRead(::grpc::ClientContext* context, const ::event_store::client::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::event_store::cluster::ClusterInfo>>(AsyncReadRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::event_store::cluster::ClusterInfo>> PrepareAsyncRead(::grpc::ClientContext* context, const ::event_store::client::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::event_store::cluster::ClusterInfo>>(PrepareAsyncReadRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void Update(::grpc::ClientContext* context, const ::event_store::cluster::GossipRequest* request, ::event_store::cluster::ClusterInfo* response, std::function<void(::grpc::Status)>) override;
      void Update(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::cluster::ClusterInfo* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Update(::grpc::ClientContext* context, const ::event_store::cluster::GossipRequest* request, ::event_store::cluster::ClusterInfo* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Update(::grpc::ClientContext* context, const ::event_store::cluster::GossipRequest* request, ::event_store::cluster::ClusterInfo* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Update(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::cluster::ClusterInfo* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Update(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::cluster::ClusterInfo* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void Read(::grpc::ClientContext* context, const ::event_store::client::Empty* request, ::event_store::cluster::ClusterInfo* response, std::function<void(::grpc::Status)>) override;
      void Read(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::cluster::ClusterInfo* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Read(::grpc::ClientContext* context, const ::event_store::client::Empty* request, ::event_store::cluster::ClusterInfo* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Read(::grpc::ClientContext* context, const ::event_store::client::Empty* request, ::event_store::cluster::ClusterInfo* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Read(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::cluster::ClusterInfo* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Read(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::cluster::ClusterInfo* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::event_store::cluster::ClusterInfo>* AsyncUpdateRaw(::grpc::ClientContext* context, const ::event_store::cluster::GossipRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::event_store::cluster::ClusterInfo>* PrepareAsyncUpdateRaw(::grpc::ClientContext* context, const ::event_store::cluster::GossipRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::event_store::cluster::ClusterInfo>* AsyncReadRaw(::grpc::ClientContext* context, const ::event_store::client::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::event_store::cluster::ClusterInfo>* PrepareAsyncReadRaw(::grpc::ClientContext* context, const ::event_store::client::Empty& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_Update_;
    const ::grpc::internal::RpcMethod rpcmethod_Read_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status Update(::grpc::ServerContext* context, const ::event_store::cluster::GossipRequest* request, ::event_store::cluster::ClusterInfo* response);
    virtual ::grpc::Status Read(::grpc::ServerContext* context, const ::event_store::client::Empty* request, ::event_store::cluster::ClusterInfo* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_Update : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Update() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_Update() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Update(::grpc::ServerContext* /*context*/, const ::event_store::cluster::GossipRequest* /*request*/, ::event_store::cluster::ClusterInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdate(::grpc::ServerContext* context, ::event_store::cluster::GossipRequest* request, ::grpc::ServerAsyncResponseWriter< ::event_store::cluster::ClusterInfo>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Read : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Read() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_Read() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Read(::grpc::ServerContext* /*context*/, const ::event_store::client::Empty* /*request*/, ::event_store::cluster::ClusterInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRead(::grpc::ServerContext* context, ::event_store::client::Empty* request, ::grpc::ServerAsyncResponseWriter< ::event_store::cluster::ClusterInfo>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_Update<WithAsyncMethod_Read<Service > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Update : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Update() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(0,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::event_store::cluster::GossipRequest, ::event_store::cluster::ClusterInfo>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::event_store::cluster::GossipRequest* request, ::event_store::cluster::ClusterInfo* response) { return this->Update(context, request, response); }));}
    void SetMessageAllocatorFor_Update(
        ::grpc::experimental::MessageAllocator< ::event_store::cluster::GossipRequest, ::event_store::cluster::ClusterInfo>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(0);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::event_store::cluster::GossipRequest, ::event_store::cluster::ClusterInfo>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Update() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Update(::grpc::ServerContext* /*context*/, const ::event_store::cluster::GossipRequest* /*request*/, ::event_store::cluster::ClusterInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Update(
      ::grpc::CallbackServerContext* /*context*/, const ::event_store::cluster::GossipRequest* /*request*/, ::event_store::cluster::ClusterInfo* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Update(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::event_store::cluster::GossipRequest* /*request*/, ::event_store::cluster::ClusterInfo* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Read : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Read() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(1,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::event_store::client::Empty, ::event_store::cluster::ClusterInfo>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::event_store::client::Empty* request, ::event_store::cluster::ClusterInfo* response) { return this->Read(context, request, response); }));}
    void SetMessageAllocatorFor_Read(
        ::grpc::experimental::MessageAllocator< ::event_store::client::Empty, ::event_store::cluster::ClusterInfo>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(1);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::event_store::client::Empty, ::event_store::cluster::ClusterInfo>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Read() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Read(::grpc::ServerContext* /*context*/, const ::event_store::client::Empty* /*request*/, ::event_store::cluster::ClusterInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Read(
      ::grpc::CallbackServerContext* /*context*/, const ::event_store::client::Empty* /*request*/, ::event_store::cluster::ClusterInfo* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Read(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::event_store::client::Empty* /*request*/, ::event_store::cluster::ClusterInfo* /*response*/)
    #endif
      { return nullptr; }
  };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef ExperimentalWithCallbackMethod_Update<ExperimentalWithCallbackMethod_Read<Service > > CallbackService;
  #endif

  typedef ExperimentalWithCallbackMethod_Update<ExperimentalWithCallbackMethod_Read<Service > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_Update : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Update() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_Update() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Update(::grpc::ServerContext* /*context*/, const ::event_store::cluster::GossipRequest* /*request*/, ::event_store::cluster::ClusterInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Read : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Read() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_Read() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Read(::grpc::ServerContext* /*context*/, const ::event_store::client::Empty* /*request*/, ::event_store::cluster::ClusterInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_Update : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Update() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_Update() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Update(::grpc::ServerContext* /*context*/, const ::event_store::cluster::GossipRequest* /*request*/, ::event_store::cluster::ClusterInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdate(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Read : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Read() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_Read() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Read(::grpc::ServerContext* /*context*/, const ::event_store::client::Empty* /*request*/, ::event_store::cluster::ClusterInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRead(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Update : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Update() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(0,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Update(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_Update() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Update(::grpc::ServerContext* /*context*/, const ::event_store::cluster::GossipRequest* /*request*/, ::event_store::cluster::ClusterInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Update(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Update(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Read : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Read() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(1,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Read(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_Read() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Read(::grpc::ServerContext* /*context*/, const ::event_store::client::Empty* /*request*/, ::event_store::cluster::ClusterInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Read(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Read(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Update : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Update() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::event_store::cluster::GossipRequest, ::event_store::cluster::ClusterInfo>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::event_store::cluster::GossipRequest, ::event_store::cluster::ClusterInfo>* streamer) {
                       return this->StreamedUpdate(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Update() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Update(::grpc::ServerContext* /*context*/, const ::event_store::cluster::GossipRequest* /*request*/, ::event_store::cluster::ClusterInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUpdate(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::event_store::cluster::GossipRequest,::event_store::cluster::ClusterInfo>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Read : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Read() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::event_store::client::Empty, ::event_store::cluster::ClusterInfo>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::event_store::client::Empty, ::event_store::cluster::ClusterInfo>* streamer) {
                       return this->StreamedRead(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Read() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Read(::grpc::ServerContext* /*context*/, const ::event_store::client::Empty* /*request*/, ::event_store::cluster::ClusterInfo* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedRead(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::event_store::client::Empty,::event_store::cluster::ClusterInfo>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_Update<WithStreamedUnaryMethod_Read<Service > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_Update<WithStreamedUnaryMethod_Read<Service > > StreamedService;
};

class Elections final {
 public:
  static constexpr char const* service_full_name() {
    return "event_store.cluster.Elections";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status ViewChange(::grpc::ClientContext* context, const ::event_store::cluster::ViewChangeRequest& request, ::event_store::client::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::event_store::client::Empty>> AsyncViewChange(::grpc::ClientContext* context, const ::event_store::cluster::ViewChangeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::event_store::client::Empty>>(AsyncViewChangeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::event_store::client::Empty>> PrepareAsyncViewChange(::grpc::ClientContext* context, const ::event_store::cluster::ViewChangeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::event_store::client::Empty>>(PrepareAsyncViewChangeRaw(context, request, cq));
    }
    virtual ::grpc::Status ViewChangeProof(::grpc::ClientContext* context, const ::event_store::cluster::ViewChangeProofRequest& request, ::event_store::client::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::event_store::client::Empty>> AsyncViewChangeProof(::grpc::ClientContext* context, const ::event_store::cluster::ViewChangeProofRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::event_store::client::Empty>>(AsyncViewChangeProofRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::event_store::client::Empty>> PrepareAsyncViewChangeProof(::grpc::ClientContext* context, const ::event_store::cluster::ViewChangeProofRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::event_store::client::Empty>>(PrepareAsyncViewChangeProofRaw(context, request, cq));
    }
    virtual ::grpc::Status Prepare(::grpc::ClientContext* context, const ::event_store::cluster::PrepareRequest& request, ::event_store::client::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::event_store::client::Empty>> AsyncPrepare(::grpc::ClientContext* context, const ::event_store::cluster::PrepareRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::event_store::client::Empty>>(AsyncPrepareRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::event_store::client::Empty>> PrepareAsyncPrepare(::grpc::ClientContext* context, const ::event_store::cluster::PrepareRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::event_store::client::Empty>>(PrepareAsyncPrepareRaw(context, request, cq));
    }
    virtual ::grpc::Status PrepareOk(::grpc::ClientContext* context, const ::event_store::cluster::PrepareOkRequest& request, ::event_store::client::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::event_store::client::Empty>> AsyncPrepareOk(::grpc::ClientContext* context, const ::event_store::cluster::PrepareOkRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::event_store::client::Empty>>(AsyncPrepareOkRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::event_store::client::Empty>> PrepareAsyncPrepareOk(::grpc::ClientContext* context, const ::event_store::cluster::PrepareOkRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::event_store::client::Empty>>(PrepareAsyncPrepareOkRaw(context, request, cq));
    }
    virtual ::grpc::Status Proposal(::grpc::ClientContext* context, const ::event_store::cluster::ProposalRequest& request, ::event_store::client::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::event_store::client::Empty>> AsyncProposal(::grpc::ClientContext* context, const ::event_store::cluster::ProposalRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::event_store::client::Empty>>(AsyncProposalRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::event_store::client::Empty>> PrepareAsyncProposal(::grpc::ClientContext* context, const ::event_store::cluster::ProposalRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::event_store::client::Empty>>(PrepareAsyncProposalRaw(context, request, cq));
    }
    virtual ::grpc::Status Accept(::grpc::ClientContext* context, const ::event_store::cluster::AcceptRequest& request, ::event_store::client::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::event_store::client::Empty>> AsyncAccept(::grpc::ClientContext* context, const ::event_store::cluster::AcceptRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::event_store::client::Empty>>(AsyncAcceptRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::event_store::client::Empty>> PrepareAsyncAccept(::grpc::ClientContext* context, const ::event_store::cluster::AcceptRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::event_store::client::Empty>>(PrepareAsyncAcceptRaw(context, request, cq));
    }
    virtual ::grpc::Status LeaderIsResigning(::grpc::ClientContext* context, const ::event_store::cluster::LeaderIsResigningRequest& request, ::event_store::client::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::event_store::client::Empty>> AsyncLeaderIsResigning(::grpc::ClientContext* context, const ::event_store::cluster::LeaderIsResigningRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::event_store::client::Empty>>(AsyncLeaderIsResigningRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::event_store::client::Empty>> PrepareAsyncLeaderIsResigning(::grpc::ClientContext* context, const ::event_store::cluster::LeaderIsResigningRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::event_store::client::Empty>>(PrepareAsyncLeaderIsResigningRaw(context, request, cq));
    }
    virtual ::grpc::Status LeaderIsResigningOk(::grpc::ClientContext* context, const ::event_store::cluster::LeaderIsResigningOkRequest& request, ::event_store::client::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::event_store::client::Empty>> AsyncLeaderIsResigningOk(::grpc::ClientContext* context, const ::event_store::cluster::LeaderIsResigningOkRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::event_store::client::Empty>>(AsyncLeaderIsResigningOkRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::event_store::client::Empty>> PrepareAsyncLeaderIsResigningOk(::grpc::ClientContext* context, const ::event_store::cluster::LeaderIsResigningOkRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::event_store::client::Empty>>(PrepareAsyncLeaderIsResigningOkRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      virtual void ViewChange(::grpc::ClientContext* context, const ::event_store::cluster::ViewChangeRequest* request, ::event_store::client::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ViewChange(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::Empty* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ViewChange(::grpc::ClientContext* context, const ::event_store::cluster::ViewChangeRequest* request, ::event_store::client::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ViewChange(::grpc::ClientContext* context, const ::event_store::cluster::ViewChangeRequest* request, ::event_store::client::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ViewChange(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ViewChange(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void ViewChangeProof(::grpc::ClientContext* context, const ::event_store::cluster::ViewChangeProofRequest* request, ::event_store::client::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ViewChangeProof(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::Empty* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ViewChangeProof(::grpc::ClientContext* context, const ::event_store::cluster::ViewChangeProofRequest* request, ::event_store::client::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ViewChangeProof(::grpc::ClientContext* context, const ::event_store::cluster::ViewChangeProofRequest* request, ::event_store::client::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ViewChangeProof(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ViewChangeProof(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void Prepare(::grpc::ClientContext* context, const ::event_store::cluster::PrepareRequest* request, ::event_store::client::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Prepare(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::Empty* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Prepare(::grpc::ClientContext* context, const ::event_store::cluster::PrepareRequest* request, ::event_store::client::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Prepare(::grpc::ClientContext* context, const ::event_store::cluster::PrepareRequest* request, ::event_store::client::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Prepare(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Prepare(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void PrepareOk(::grpc::ClientContext* context, const ::event_store::cluster::PrepareOkRequest* request, ::event_store::client::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PrepareOk(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::Empty* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PrepareOk(::grpc::ClientContext* context, const ::event_store::cluster::PrepareOkRequest* request, ::event_store::client::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PrepareOk(::grpc::ClientContext* context, const ::event_store::cluster::PrepareOkRequest* request, ::event_store::client::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void PrepareOk(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void PrepareOk(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void Proposal(::grpc::ClientContext* context, const ::event_store::cluster::ProposalRequest* request, ::event_store::client::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Proposal(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::Empty* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Proposal(::grpc::ClientContext* context, const ::event_store::cluster::ProposalRequest* request, ::event_store::client::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Proposal(::grpc::ClientContext* context, const ::event_store::cluster::ProposalRequest* request, ::event_store::client::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Proposal(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Proposal(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void Accept(::grpc::ClientContext* context, const ::event_store::cluster::AcceptRequest* request, ::event_store::client::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Accept(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::Empty* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Accept(::grpc::ClientContext* context, const ::event_store::cluster::AcceptRequest* request, ::event_store::client::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Accept(::grpc::ClientContext* context, const ::event_store::cluster::AcceptRequest* request, ::event_store::client::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Accept(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Accept(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void LeaderIsResigning(::grpc::ClientContext* context, const ::event_store::cluster::LeaderIsResigningRequest* request, ::event_store::client::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void LeaderIsResigning(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::Empty* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void LeaderIsResigning(::grpc::ClientContext* context, const ::event_store::cluster::LeaderIsResigningRequest* request, ::event_store::client::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void LeaderIsResigning(::grpc::ClientContext* context, const ::event_store::cluster::LeaderIsResigningRequest* request, ::event_store::client::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void LeaderIsResigning(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void LeaderIsResigning(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void LeaderIsResigningOk(::grpc::ClientContext* context, const ::event_store::cluster::LeaderIsResigningOkRequest* request, ::event_store::client::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void LeaderIsResigningOk(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::Empty* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void LeaderIsResigningOk(::grpc::ClientContext* context, const ::event_store::cluster::LeaderIsResigningOkRequest* request, ::event_store::client::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void LeaderIsResigningOk(::grpc::ClientContext* context, const ::event_store::cluster::LeaderIsResigningOkRequest* request, ::event_store::client::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void LeaderIsResigningOk(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void LeaderIsResigningOk(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::event_store::client::Empty>* AsyncViewChangeRaw(::grpc::ClientContext* context, const ::event_store::cluster::ViewChangeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::event_store::client::Empty>* PrepareAsyncViewChangeRaw(::grpc::ClientContext* context, const ::event_store::cluster::ViewChangeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::event_store::client::Empty>* AsyncViewChangeProofRaw(::grpc::ClientContext* context, const ::event_store::cluster::ViewChangeProofRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::event_store::client::Empty>* PrepareAsyncViewChangeProofRaw(::grpc::ClientContext* context, const ::event_store::cluster::ViewChangeProofRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::event_store::client::Empty>* AsyncPrepareRaw(::grpc::ClientContext* context, const ::event_store::cluster::PrepareRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::event_store::client::Empty>* PrepareAsyncPrepareRaw(::grpc::ClientContext* context, const ::event_store::cluster::PrepareRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::event_store::client::Empty>* AsyncPrepareOkRaw(::grpc::ClientContext* context, const ::event_store::cluster::PrepareOkRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::event_store::client::Empty>* PrepareAsyncPrepareOkRaw(::grpc::ClientContext* context, const ::event_store::cluster::PrepareOkRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::event_store::client::Empty>* AsyncProposalRaw(::grpc::ClientContext* context, const ::event_store::cluster::ProposalRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::event_store::client::Empty>* PrepareAsyncProposalRaw(::grpc::ClientContext* context, const ::event_store::cluster::ProposalRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::event_store::client::Empty>* AsyncAcceptRaw(::grpc::ClientContext* context, const ::event_store::cluster::AcceptRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::event_store::client::Empty>* PrepareAsyncAcceptRaw(::grpc::ClientContext* context, const ::event_store::cluster::AcceptRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::event_store::client::Empty>* AsyncLeaderIsResigningRaw(::grpc::ClientContext* context, const ::event_store::cluster::LeaderIsResigningRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::event_store::client::Empty>* PrepareAsyncLeaderIsResigningRaw(::grpc::ClientContext* context, const ::event_store::cluster::LeaderIsResigningRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::event_store::client::Empty>* AsyncLeaderIsResigningOkRaw(::grpc::ClientContext* context, const ::event_store::cluster::LeaderIsResigningOkRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::event_store::client::Empty>* PrepareAsyncLeaderIsResigningOkRaw(::grpc::ClientContext* context, const ::event_store::cluster::LeaderIsResigningOkRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status ViewChange(::grpc::ClientContext* context, const ::event_store::cluster::ViewChangeRequest& request, ::event_store::client::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::event_store::client::Empty>> AsyncViewChange(::grpc::ClientContext* context, const ::event_store::cluster::ViewChangeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::event_store::client::Empty>>(AsyncViewChangeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::event_store::client::Empty>> PrepareAsyncViewChange(::grpc::ClientContext* context, const ::event_store::cluster::ViewChangeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::event_store::client::Empty>>(PrepareAsyncViewChangeRaw(context, request, cq));
    }
    ::grpc::Status ViewChangeProof(::grpc::ClientContext* context, const ::event_store::cluster::ViewChangeProofRequest& request, ::event_store::client::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::event_store::client::Empty>> AsyncViewChangeProof(::grpc::ClientContext* context, const ::event_store::cluster::ViewChangeProofRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::event_store::client::Empty>>(AsyncViewChangeProofRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::event_store::client::Empty>> PrepareAsyncViewChangeProof(::grpc::ClientContext* context, const ::event_store::cluster::ViewChangeProofRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::event_store::client::Empty>>(PrepareAsyncViewChangeProofRaw(context, request, cq));
    }
    ::grpc::Status Prepare(::grpc::ClientContext* context, const ::event_store::cluster::PrepareRequest& request, ::event_store::client::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::event_store::client::Empty>> AsyncPrepare(::grpc::ClientContext* context, const ::event_store::cluster::PrepareRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::event_store::client::Empty>>(AsyncPrepareRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::event_store::client::Empty>> PrepareAsyncPrepare(::grpc::ClientContext* context, const ::event_store::cluster::PrepareRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::event_store::client::Empty>>(PrepareAsyncPrepareRaw(context, request, cq));
    }
    ::grpc::Status PrepareOk(::grpc::ClientContext* context, const ::event_store::cluster::PrepareOkRequest& request, ::event_store::client::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::event_store::client::Empty>> AsyncPrepareOk(::grpc::ClientContext* context, const ::event_store::cluster::PrepareOkRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::event_store::client::Empty>>(AsyncPrepareOkRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::event_store::client::Empty>> PrepareAsyncPrepareOk(::grpc::ClientContext* context, const ::event_store::cluster::PrepareOkRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::event_store::client::Empty>>(PrepareAsyncPrepareOkRaw(context, request, cq));
    }
    ::grpc::Status Proposal(::grpc::ClientContext* context, const ::event_store::cluster::ProposalRequest& request, ::event_store::client::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::event_store::client::Empty>> AsyncProposal(::grpc::ClientContext* context, const ::event_store::cluster::ProposalRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::event_store::client::Empty>>(AsyncProposalRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::event_store::client::Empty>> PrepareAsyncProposal(::grpc::ClientContext* context, const ::event_store::cluster::ProposalRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::event_store::client::Empty>>(PrepareAsyncProposalRaw(context, request, cq));
    }
    ::grpc::Status Accept(::grpc::ClientContext* context, const ::event_store::cluster::AcceptRequest& request, ::event_store::client::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::event_store::client::Empty>> AsyncAccept(::grpc::ClientContext* context, const ::event_store::cluster::AcceptRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::event_store::client::Empty>>(AsyncAcceptRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::event_store::client::Empty>> PrepareAsyncAccept(::grpc::ClientContext* context, const ::event_store::cluster::AcceptRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::event_store::client::Empty>>(PrepareAsyncAcceptRaw(context, request, cq));
    }
    ::grpc::Status LeaderIsResigning(::grpc::ClientContext* context, const ::event_store::cluster::LeaderIsResigningRequest& request, ::event_store::client::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::event_store::client::Empty>> AsyncLeaderIsResigning(::grpc::ClientContext* context, const ::event_store::cluster::LeaderIsResigningRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::event_store::client::Empty>>(AsyncLeaderIsResigningRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::event_store::client::Empty>> PrepareAsyncLeaderIsResigning(::grpc::ClientContext* context, const ::event_store::cluster::LeaderIsResigningRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::event_store::client::Empty>>(PrepareAsyncLeaderIsResigningRaw(context, request, cq));
    }
    ::grpc::Status LeaderIsResigningOk(::grpc::ClientContext* context, const ::event_store::cluster::LeaderIsResigningOkRequest& request, ::event_store::client::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::event_store::client::Empty>> AsyncLeaderIsResigningOk(::grpc::ClientContext* context, const ::event_store::cluster::LeaderIsResigningOkRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::event_store::client::Empty>>(AsyncLeaderIsResigningOkRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::event_store::client::Empty>> PrepareAsyncLeaderIsResigningOk(::grpc::ClientContext* context, const ::event_store::cluster::LeaderIsResigningOkRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::event_store::client::Empty>>(PrepareAsyncLeaderIsResigningOkRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void ViewChange(::grpc::ClientContext* context, const ::event_store::cluster::ViewChangeRequest* request, ::event_store::client::Empty* response, std::function<void(::grpc::Status)>) override;
      void ViewChange(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::Empty* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ViewChange(::grpc::ClientContext* context, const ::event_store::cluster::ViewChangeRequest* request, ::event_store::client::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ViewChange(::grpc::ClientContext* context, const ::event_store::cluster::ViewChangeRequest* request, ::event_store::client::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ViewChange(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ViewChange(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ViewChangeProof(::grpc::ClientContext* context, const ::event_store::cluster::ViewChangeProofRequest* request, ::event_store::client::Empty* response, std::function<void(::grpc::Status)>) override;
      void ViewChangeProof(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::Empty* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ViewChangeProof(::grpc::ClientContext* context, const ::event_store::cluster::ViewChangeProofRequest* request, ::event_store::client::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ViewChangeProof(::grpc::ClientContext* context, const ::event_store::cluster::ViewChangeProofRequest* request, ::event_store::client::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ViewChangeProof(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ViewChangeProof(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void Prepare(::grpc::ClientContext* context, const ::event_store::cluster::PrepareRequest* request, ::event_store::client::Empty* response, std::function<void(::grpc::Status)>) override;
      void Prepare(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::Empty* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Prepare(::grpc::ClientContext* context, const ::event_store::cluster::PrepareRequest* request, ::event_store::client::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Prepare(::grpc::ClientContext* context, const ::event_store::cluster::PrepareRequest* request, ::event_store::client::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Prepare(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Prepare(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void PrepareOk(::grpc::ClientContext* context, const ::event_store::cluster::PrepareOkRequest* request, ::event_store::client::Empty* response, std::function<void(::grpc::Status)>) override;
      void PrepareOk(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::Empty* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PrepareOk(::grpc::ClientContext* context, const ::event_store::cluster::PrepareOkRequest* request, ::event_store::client::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PrepareOk(::grpc::ClientContext* context, const ::event_store::cluster::PrepareOkRequest* request, ::event_store::client::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void PrepareOk(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void PrepareOk(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void Proposal(::grpc::ClientContext* context, const ::event_store::cluster::ProposalRequest* request, ::event_store::client::Empty* response, std::function<void(::grpc::Status)>) override;
      void Proposal(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::Empty* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Proposal(::grpc::ClientContext* context, const ::event_store::cluster::ProposalRequest* request, ::event_store::client::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Proposal(::grpc::ClientContext* context, const ::event_store::cluster::ProposalRequest* request, ::event_store::client::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Proposal(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Proposal(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void Accept(::grpc::ClientContext* context, const ::event_store::cluster::AcceptRequest* request, ::event_store::client::Empty* response, std::function<void(::grpc::Status)>) override;
      void Accept(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::Empty* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Accept(::grpc::ClientContext* context, const ::event_store::cluster::AcceptRequest* request, ::event_store::client::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Accept(::grpc::ClientContext* context, const ::event_store::cluster::AcceptRequest* request, ::event_store::client::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Accept(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Accept(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void LeaderIsResigning(::grpc::ClientContext* context, const ::event_store::cluster::LeaderIsResigningRequest* request, ::event_store::client::Empty* response, std::function<void(::grpc::Status)>) override;
      void LeaderIsResigning(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::Empty* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void LeaderIsResigning(::grpc::ClientContext* context, const ::event_store::cluster::LeaderIsResigningRequest* request, ::event_store::client::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void LeaderIsResigning(::grpc::ClientContext* context, const ::event_store::cluster::LeaderIsResigningRequest* request, ::event_store::client::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void LeaderIsResigning(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void LeaderIsResigning(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void LeaderIsResigningOk(::grpc::ClientContext* context, const ::event_store::cluster::LeaderIsResigningOkRequest* request, ::event_store::client::Empty* response, std::function<void(::grpc::Status)>) override;
      void LeaderIsResigningOk(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::Empty* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void LeaderIsResigningOk(::grpc::ClientContext* context, const ::event_store::cluster::LeaderIsResigningOkRequest* request, ::event_store::client::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void LeaderIsResigningOk(::grpc::ClientContext* context, const ::event_store::cluster::LeaderIsResigningOkRequest* request, ::event_store::client::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void LeaderIsResigningOk(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void LeaderIsResigningOk(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::event_store::client::Empty* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::event_store::client::Empty>* AsyncViewChangeRaw(::grpc::ClientContext* context, const ::event_store::cluster::ViewChangeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::event_store::client::Empty>* PrepareAsyncViewChangeRaw(::grpc::ClientContext* context, const ::event_store::cluster::ViewChangeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::event_store::client::Empty>* AsyncViewChangeProofRaw(::grpc::ClientContext* context, const ::event_store::cluster::ViewChangeProofRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::event_store::client::Empty>* PrepareAsyncViewChangeProofRaw(::grpc::ClientContext* context, const ::event_store::cluster::ViewChangeProofRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::event_store::client::Empty>* AsyncPrepareRaw(::grpc::ClientContext* context, const ::event_store::cluster::PrepareRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::event_store::client::Empty>* PrepareAsyncPrepareRaw(::grpc::ClientContext* context, const ::event_store::cluster::PrepareRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::event_store::client::Empty>* AsyncPrepareOkRaw(::grpc::ClientContext* context, const ::event_store::cluster::PrepareOkRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::event_store::client::Empty>* PrepareAsyncPrepareOkRaw(::grpc::ClientContext* context, const ::event_store::cluster::PrepareOkRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::event_store::client::Empty>* AsyncProposalRaw(::grpc::ClientContext* context, const ::event_store::cluster::ProposalRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::event_store::client::Empty>* PrepareAsyncProposalRaw(::grpc::ClientContext* context, const ::event_store::cluster::ProposalRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::event_store::client::Empty>* AsyncAcceptRaw(::grpc::ClientContext* context, const ::event_store::cluster::AcceptRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::event_store::client::Empty>* PrepareAsyncAcceptRaw(::grpc::ClientContext* context, const ::event_store::cluster::AcceptRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::event_store::client::Empty>* AsyncLeaderIsResigningRaw(::grpc::ClientContext* context, const ::event_store::cluster::LeaderIsResigningRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::event_store::client::Empty>* PrepareAsyncLeaderIsResigningRaw(::grpc::ClientContext* context, const ::event_store::cluster::LeaderIsResigningRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::event_store::client::Empty>* AsyncLeaderIsResigningOkRaw(::grpc::ClientContext* context, const ::event_store::cluster::LeaderIsResigningOkRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::event_store::client::Empty>* PrepareAsyncLeaderIsResigningOkRaw(::grpc::ClientContext* context, const ::event_store::cluster::LeaderIsResigningOkRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_ViewChange_;
    const ::grpc::internal::RpcMethod rpcmethod_ViewChangeProof_;
    const ::grpc::internal::RpcMethod rpcmethod_Prepare_;
    const ::grpc::internal::RpcMethod rpcmethod_PrepareOk_;
    const ::grpc::internal::RpcMethod rpcmethod_Proposal_;
    const ::grpc::internal::RpcMethod rpcmethod_Accept_;
    const ::grpc::internal::RpcMethod rpcmethod_LeaderIsResigning_;
    const ::grpc::internal::RpcMethod rpcmethod_LeaderIsResigningOk_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status ViewChange(::grpc::ServerContext* context, const ::event_store::cluster::ViewChangeRequest* request, ::event_store::client::Empty* response);
    virtual ::grpc::Status ViewChangeProof(::grpc::ServerContext* context, const ::event_store::cluster::ViewChangeProofRequest* request, ::event_store::client::Empty* response);
    virtual ::grpc::Status Prepare(::grpc::ServerContext* context, const ::event_store::cluster::PrepareRequest* request, ::event_store::client::Empty* response);
    virtual ::grpc::Status PrepareOk(::grpc::ServerContext* context, const ::event_store::cluster::PrepareOkRequest* request, ::event_store::client::Empty* response);
    virtual ::grpc::Status Proposal(::grpc::ServerContext* context, const ::event_store::cluster::ProposalRequest* request, ::event_store::client::Empty* response);
    virtual ::grpc::Status Accept(::grpc::ServerContext* context, const ::event_store::cluster::AcceptRequest* request, ::event_store::client::Empty* response);
    virtual ::grpc::Status LeaderIsResigning(::grpc::ServerContext* context, const ::event_store::cluster::LeaderIsResigningRequest* request, ::event_store::client::Empty* response);
    virtual ::grpc::Status LeaderIsResigningOk(::grpc::ServerContext* context, const ::event_store::cluster::LeaderIsResigningOkRequest* request, ::event_store::client::Empty* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_ViewChange : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ViewChange() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_ViewChange() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ViewChange(::grpc::ServerContext* /*context*/, const ::event_store::cluster::ViewChangeRequest* /*request*/, ::event_store::client::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestViewChange(::grpc::ServerContext* context, ::event_store::cluster::ViewChangeRequest* request, ::grpc::ServerAsyncResponseWriter< ::event_store::client::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ViewChangeProof : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ViewChangeProof() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_ViewChangeProof() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ViewChangeProof(::grpc::ServerContext* /*context*/, const ::event_store::cluster::ViewChangeProofRequest* /*request*/, ::event_store::client::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestViewChangeProof(::grpc::ServerContext* context, ::event_store::cluster::ViewChangeProofRequest* request, ::grpc::ServerAsyncResponseWriter< ::event_store::client::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Prepare : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Prepare() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_Prepare() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Prepare(::grpc::ServerContext* /*context*/, const ::event_store::cluster::PrepareRequest* /*request*/, ::event_store::client::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPrepare(::grpc::ServerContext* context, ::event_store::cluster::PrepareRequest* request, ::grpc::ServerAsyncResponseWriter< ::event_store::client::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PrepareOk : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PrepareOk() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_PrepareOk() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PrepareOk(::grpc::ServerContext* /*context*/, const ::event_store::cluster::PrepareOkRequest* /*request*/, ::event_store::client::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPrepareOk(::grpc::ServerContext* context, ::event_store::cluster::PrepareOkRequest* request, ::grpc::ServerAsyncResponseWriter< ::event_store::client::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Proposal : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Proposal() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_Proposal() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Proposal(::grpc::ServerContext* /*context*/, const ::event_store::cluster::ProposalRequest* /*request*/, ::event_store::client::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestProposal(::grpc::ServerContext* context, ::event_store::cluster::ProposalRequest* request, ::grpc::ServerAsyncResponseWriter< ::event_store::client::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Accept : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Accept() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_Accept() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Accept(::grpc::ServerContext* /*context*/, const ::event_store::cluster::AcceptRequest* /*request*/, ::event_store::client::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAccept(::grpc::ServerContext* context, ::event_store::cluster::AcceptRequest* request, ::grpc::ServerAsyncResponseWriter< ::event_store::client::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_LeaderIsResigning : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_LeaderIsResigning() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_LeaderIsResigning() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LeaderIsResigning(::grpc::ServerContext* /*context*/, const ::event_store::cluster::LeaderIsResigningRequest* /*request*/, ::event_store::client::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLeaderIsResigning(::grpc::ServerContext* context, ::event_store::cluster::LeaderIsResigningRequest* request, ::grpc::ServerAsyncResponseWriter< ::event_store::client::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_LeaderIsResigningOk : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_LeaderIsResigningOk() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_LeaderIsResigningOk() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LeaderIsResigningOk(::grpc::ServerContext* /*context*/, const ::event_store::cluster::LeaderIsResigningOkRequest* /*request*/, ::event_store::client::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLeaderIsResigningOk(::grpc::ServerContext* context, ::event_store::cluster::LeaderIsResigningOkRequest* request, ::grpc::ServerAsyncResponseWriter< ::event_store::client::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_ViewChange<WithAsyncMethod_ViewChangeProof<WithAsyncMethod_Prepare<WithAsyncMethod_PrepareOk<WithAsyncMethod_Proposal<WithAsyncMethod_Accept<WithAsyncMethod_LeaderIsResigning<WithAsyncMethod_LeaderIsResigningOk<Service > > > > > > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ViewChange : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ViewChange() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(0,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::event_store::cluster::ViewChangeRequest, ::event_store::client::Empty>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::event_store::cluster::ViewChangeRequest* request, ::event_store::client::Empty* response) { return this->ViewChange(context, request, response); }));}
    void SetMessageAllocatorFor_ViewChange(
        ::grpc::experimental::MessageAllocator< ::event_store::cluster::ViewChangeRequest, ::event_store::client::Empty>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(0);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::event_store::cluster::ViewChangeRequest, ::event_store::client::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ViewChange() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ViewChange(::grpc::ServerContext* /*context*/, const ::event_store::cluster::ViewChangeRequest* /*request*/, ::event_store::client::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ViewChange(
      ::grpc::CallbackServerContext* /*context*/, const ::event_store::cluster::ViewChangeRequest* /*request*/, ::event_store::client::Empty* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ViewChange(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::event_store::cluster::ViewChangeRequest* /*request*/, ::event_store::client::Empty* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ViewChangeProof : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ViewChangeProof() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(1,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::event_store::cluster::ViewChangeProofRequest, ::event_store::client::Empty>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::event_store::cluster::ViewChangeProofRequest* request, ::event_store::client::Empty* response) { return this->ViewChangeProof(context, request, response); }));}
    void SetMessageAllocatorFor_ViewChangeProof(
        ::grpc::experimental::MessageAllocator< ::event_store::cluster::ViewChangeProofRequest, ::event_store::client::Empty>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(1);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::event_store::cluster::ViewChangeProofRequest, ::event_store::client::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ViewChangeProof() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ViewChangeProof(::grpc::ServerContext* /*context*/, const ::event_store::cluster::ViewChangeProofRequest* /*request*/, ::event_store::client::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ViewChangeProof(
      ::grpc::CallbackServerContext* /*context*/, const ::event_store::cluster::ViewChangeProofRequest* /*request*/, ::event_store::client::Empty* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ViewChangeProof(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::event_store::cluster::ViewChangeProofRequest* /*request*/, ::event_store::client::Empty* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Prepare : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Prepare() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(2,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::event_store::cluster::PrepareRequest, ::event_store::client::Empty>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::event_store::cluster::PrepareRequest* request, ::event_store::client::Empty* response) { return this->Prepare(context, request, response); }));}
    void SetMessageAllocatorFor_Prepare(
        ::grpc::experimental::MessageAllocator< ::event_store::cluster::PrepareRequest, ::event_store::client::Empty>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(2);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::event_store::cluster::PrepareRequest, ::event_store::client::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Prepare() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Prepare(::grpc::ServerContext* /*context*/, const ::event_store::cluster::PrepareRequest* /*request*/, ::event_store::client::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Prepare(
      ::grpc::CallbackServerContext* /*context*/, const ::event_store::cluster::PrepareRequest* /*request*/, ::event_store::client::Empty* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Prepare(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::event_store::cluster::PrepareRequest* /*request*/, ::event_store::client::Empty* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_PrepareOk : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_PrepareOk() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(3,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::event_store::cluster::PrepareOkRequest, ::event_store::client::Empty>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::event_store::cluster::PrepareOkRequest* request, ::event_store::client::Empty* response) { return this->PrepareOk(context, request, response); }));}
    void SetMessageAllocatorFor_PrepareOk(
        ::grpc::experimental::MessageAllocator< ::event_store::cluster::PrepareOkRequest, ::event_store::client::Empty>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(3);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::event_store::cluster::PrepareOkRequest, ::event_store::client::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_PrepareOk() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PrepareOk(::grpc::ServerContext* /*context*/, const ::event_store::cluster::PrepareOkRequest* /*request*/, ::event_store::client::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PrepareOk(
      ::grpc::CallbackServerContext* /*context*/, const ::event_store::cluster::PrepareOkRequest* /*request*/, ::event_store::client::Empty* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PrepareOk(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::event_store::cluster::PrepareOkRequest* /*request*/, ::event_store::client::Empty* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Proposal : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Proposal() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(4,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::event_store::cluster::ProposalRequest, ::event_store::client::Empty>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::event_store::cluster::ProposalRequest* request, ::event_store::client::Empty* response) { return this->Proposal(context, request, response); }));}
    void SetMessageAllocatorFor_Proposal(
        ::grpc::experimental::MessageAllocator< ::event_store::cluster::ProposalRequest, ::event_store::client::Empty>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(4);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::event_store::cluster::ProposalRequest, ::event_store::client::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Proposal() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Proposal(::grpc::ServerContext* /*context*/, const ::event_store::cluster::ProposalRequest* /*request*/, ::event_store::client::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Proposal(
      ::grpc::CallbackServerContext* /*context*/, const ::event_store::cluster::ProposalRequest* /*request*/, ::event_store::client::Empty* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Proposal(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::event_store::cluster::ProposalRequest* /*request*/, ::event_store::client::Empty* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Accept : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Accept() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(5,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::event_store::cluster::AcceptRequest, ::event_store::client::Empty>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::event_store::cluster::AcceptRequest* request, ::event_store::client::Empty* response) { return this->Accept(context, request, response); }));}
    void SetMessageAllocatorFor_Accept(
        ::grpc::experimental::MessageAllocator< ::event_store::cluster::AcceptRequest, ::event_store::client::Empty>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(5);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::event_store::cluster::AcceptRequest, ::event_store::client::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Accept() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Accept(::grpc::ServerContext* /*context*/, const ::event_store::cluster::AcceptRequest* /*request*/, ::event_store::client::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Accept(
      ::grpc::CallbackServerContext* /*context*/, const ::event_store::cluster::AcceptRequest* /*request*/, ::event_store::client::Empty* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Accept(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::event_store::cluster::AcceptRequest* /*request*/, ::event_store::client::Empty* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_LeaderIsResigning : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_LeaderIsResigning() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(6,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::event_store::cluster::LeaderIsResigningRequest, ::event_store::client::Empty>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::event_store::cluster::LeaderIsResigningRequest* request, ::event_store::client::Empty* response) { return this->LeaderIsResigning(context, request, response); }));}
    void SetMessageAllocatorFor_LeaderIsResigning(
        ::grpc::experimental::MessageAllocator< ::event_store::cluster::LeaderIsResigningRequest, ::event_store::client::Empty>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(6);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::event_store::cluster::LeaderIsResigningRequest, ::event_store::client::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_LeaderIsResigning() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LeaderIsResigning(::grpc::ServerContext* /*context*/, const ::event_store::cluster::LeaderIsResigningRequest* /*request*/, ::event_store::client::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* LeaderIsResigning(
      ::grpc::CallbackServerContext* /*context*/, const ::event_store::cluster::LeaderIsResigningRequest* /*request*/, ::event_store::client::Empty* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* LeaderIsResigning(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::event_store::cluster::LeaderIsResigningRequest* /*request*/, ::event_store::client::Empty* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_LeaderIsResigningOk : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_LeaderIsResigningOk() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(7,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::event_store::cluster::LeaderIsResigningOkRequest, ::event_store::client::Empty>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::event_store::cluster::LeaderIsResigningOkRequest* request, ::event_store::client::Empty* response) { return this->LeaderIsResigningOk(context, request, response); }));}
    void SetMessageAllocatorFor_LeaderIsResigningOk(
        ::grpc::experimental::MessageAllocator< ::event_store::cluster::LeaderIsResigningOkRequest, ::event_store::client::Empty>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(7);
    #endif
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::event_store::cluster::LeaderIsResigningOkRequest, ::event_store::client::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_LeaderIsResigningOk() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LeaderIsResigningOk(::grpc::ServerContext* /*context*/, const ::event_store::cluster::LeaderIsResigningOkRequest* /*request*/, ::event_store::client::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* LeaderIsResigningOk(
      ::grpc::CallbackServerContext* /*context*/, const ::event_store::cluster::LeaderIsResigningOkRequest* /*request*/, ::event_store::client::Empty* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* LeaderIsResigningOk(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::event_store::cluster::LeaderIsResigningOkRequest* /*request*/, ::event_store::client::Empty* /*response*/)
    #endif
      { return nullptr; }
  };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef ExperimentalWithCallbackMethod_ViewChange<ExperimentalWithCallbackMethod_ViewChangeProof<ExperimentalWithCallbackMethod_Prepare<ExperimentalWithCallbackMethod_PrepareOk<ExperimentalWithCallbackMethod_Proposal<ExperimentalWithCallbackMethod_Accept<ExperimentalWithCallbackMethod_LeaderIsResigning<ExperimentalWithCallbackMethod_LeaderIsResigningOk<Service > > > > > > > > CallbackService;
  #endif

  typedef ExperimentalWithCallbackMethod_ViewChange<ExperimentalWithCallbackMethod_ViewChangeProof<ExperimentalWithCallbackMethod_Prepare<ExperimentalWithCallbackMethod_PrepareOk<ExperimentalWithCallbackMethod_Proposal<ExperimentalWithCallbackMethod_Accept<ExperimentalWithCallbackMethod_LeaderIsResigning<ExperimentalWithCallbackMethod_LeaderIsResigningOk<Service > > > > > > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_ViewChange : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ViewChange() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_ViewChange() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ViewChange(::grpc::ServerContext* /*context*/, const ::event_store::cluster::ViewChangeRequest* /*request*/, ::event_store::client::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ViewChangeProof : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ViewChangeProof() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_ViewChangeProof() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ViewChangeProof(::grpc::ServerContext* /*context*/, const ::event_store::cluster::ViewChangeProofRequest* /*request*/, ::event_store::client::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Prepare : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Prepare() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_Prepare() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Prepare(::grpc::ServerContext* /*context*/, const ::event_store::cluster::PrepareRequest* /*request*/, ::event_store::client::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PrepareOk : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PrepareOk() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_PrepareOk() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PrepareOk(::grpc::ServerContext* /*context*/, const ::event_store::cluster::PrepareOkRequest* /*request*/, ::event_store::client::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Proposal : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Proposal() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_Proposal() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Proposal(::grpc::ServerContext* /*context*/, const ::event_store::cluster::ProposalRequest* /*request*/, ::event_store::client::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Accept : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Accept() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_Accept() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Accept(::grpc::ServerContext* /*context*/, const ::event_store::cluster::AcceptRequest* /*request*/, ::event_store::client::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_LeaderIsResigning : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_LeaderIsResigning() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_LeaderIsResigning() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LeaderIsResigning(::grpc::ServerContext* /*context*/, const ::event_store::cluster::LeaderIsResigningRequest* /*request*/, ::event_store::client::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_LeaderIsResigningOk : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_LeaderIsResigningOk() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_LeaderIsResigningOk() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LeaderIsResigningOk(::grpc::ServerContext* /*context*/, const ::event_store::cluster::LeaderIsResigningOkRequest* /*request*/, ::event_store::client::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_ViewChange : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ViewChange() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_ViewChange() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ViewChange(::grpc::ServerContext* /*context*/, const ::event_store::cluster::ViewChangeRequest* /*request*/, ::event_store::client::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestViewChange(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ViewChangeProof : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ViewChangeProof() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_ViewChangeProof() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ViewChangeProof(::grpc::ServerContext* /*context*/, const ::event_store::cluster::ViewChangeProofRequest* /*request*/, ::event_store::client::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestViewChangeProof(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Prepare : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Prepare() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_Prepare() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Prepare(::grpc::ServerContext* /*context*/, const ::event_store::cluster::PrepareRequest* /*request*/, ::event_store::client::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPrepare(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PrepareOk : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PrepareOk() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_PrepareOk() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PrepareOk(::grpc::ServerContext* /*context*/, const ::event_store::cluster::PrepareOkRequest* /*request*/, ::event_store::client::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPrepareOk(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Proposal : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Proposal() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_Proposal() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Proposal(::grpc::ServerContext* /*context*/, const ::event_store::cluster::ProposalRequest* /*request*/, ::event_store::client::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestProposal(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Accept : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Accept() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_Accept() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Accept(::grpc::ServerContext* /*context*/, const ::event_store::cluster::AcceptRequest* /*request*/, ::event_store::client::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAccept(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_LeaderIsResigning : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_LeaderIsResigning() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_LeaderIsResigning() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LeaderIsResigning(::grpc::ServerContext* /*context*/, const ::event_store::cluster::LeaderIsResigningRequest* /*request*/, ::event_store::client::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLeaderIsResigning(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_LeaderIsResigningOk : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_LeaderIsResigningOk() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_LeaderIsResigningOk() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LeaderIsResigningOk(::grpc::ServerContext* /*context*/, const ::event_store::cluster::LeaderIsResigningOkRequest* /*request*/, ::event_store::client::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLeaderIsResigningOk(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ViewChange : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ViewChange() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(0,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ViewChange(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ViewChange() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ViewChange(::grpc::ServerContext* /*context*/, const ::event_store::cluster::ViewChangeRequest* /*request*/, ::event_store::client::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ViewChange(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ViewChange(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ViewChangeProof : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ViewChangeProof() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(1,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ViewChangeProof(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ViewChangeProof() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ViewChangeProof(::grpc::ServerContext* /*context*/, const ::event_store::cluster::ViewChangeProofRequest* /*request*/, ::event_store::client::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ViewChangeProof(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ViewChangeProof(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Prepare : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Prepare() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(2,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Prepare(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_Prepare() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Prepare(::grpc::ServerContext* /*context*/, const ::event_store::cluster::PrepareRequest* /*request*/, ::event_store::client::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Prepare(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Prepare(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_PrepareOk : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_PrepareOk() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(3,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->PrepareOk(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_PrepareOk() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PrepareOk(::grpc::ServerContext* /*context*/, const ::event_store::cluster::PrepareOkRequest* /*request*/, ::event_store::client::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* PrepareOk(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* PrepareOk(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Proposal : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Proposal() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(4,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Proposal(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_Proposal() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Proposal(::grpc::ServerContext* /*context*/, const ::event_store::cluster::ProposalRequest* /*request*/, ::event_store::client::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Proposal(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Proposal(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Accept : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Accept() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(5,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Accept(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_Accept() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Accept(::grpc::ServerContext* /*context*/, const ::event_store::cluster::AcceptRequest* /*request*/, ::event_store::client::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Accept(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Accept(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_LeaderIsResigning : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_LeaderIsResigning() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(6,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->LeaderIsResigning(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_LeaderIsResigning() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LeaderIsResigning(::grpc::ServerContext* /*context*/, const ::event_store::cluster::LeaderIsResigningRequest* /*request*/, ::event_store::client::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* LeaderIsResigning(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* LeaderIsResigning(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_LeaderIsResigningOk : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_LeaderIsResigningOk() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(7,
          new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->LeaderIsResigningOk(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_LeaderIsResigningOk() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LeaderIsResigningOk(::grpc::ServerContext* /*context*/, const ::event_store::cluster::LeaderIsResigningOkRequest* /*request*/, ::event_store::client::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* LeaderIsResigningOk(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* LeaderIsResigningOk(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ViewChange : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ViewChange() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::event_store::cluster::ViewChangeRequest, ::event_store::client::Empty>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::event_store::cluster::ViewChangeRequest, ::event_store::client::Empty>* streamer) {
                       return this->StreamedViewChange(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ViewChange() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ViewChange(::grpc::ServerContext* /*context*/, const ::event_store::cluster::ViewChangeRequest* /*request*/, ::event_store::client::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedViewChange(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::event_store::cluster::ViewChangeRequest,::event_store::client::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ViewChangeProof : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ViewChangeProof() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::event_store::cluster::ViewChangeProofRequest, ::event_store::client::Empty>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::event_store::cluster::ViewChangeProofRequest, ::event_store::client::Empty>* streamer) {
                       return this->StreamedViewChangeProof(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ViewChangeProof() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ViewChangeProof(::grpc::ServerContext* /*context*/, const ::event_store::cluster::ViewChangeProofRequest* /*request*/, ::event_store::client::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedViewChangeProof(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::event_store::cluster::ViewChangeProofRequest,::event_store::client::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Prepare : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Prepare() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::event_store::cluster::PrepareRequest, ::event_store::client::Empty>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::event_store::cluster::PrepareRequest, ::event_store::client::Empty>* streamer) {
                       return this->StreamedPrepare(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Prepare() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Prepare(::grpc::ServerContext* /*context*/, const ::event_store::cluster::PrepareRequest* /*request*/, ::event_store::client::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPrepare(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::event_store::cluster::PrepareRequest,::event_store::client::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PrepareOk : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PrepareOk() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::event_store::cluster::PrepareOkRequest, ::event_store::client::Empty>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::event_store::cluster::PrepareOkRequest, ::event_store::client::Empty>* streamer) {
                       return this->StreamedPrepareOk(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_PrepareOk() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PrepareOk(::grpc::ServerContext* /*context*/, const ::event_store::cluster::PrepareOkRequest* /*request*/, ::event_store::client::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPrepareOk(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::event_store::cluster::PrepareOkRequest,::event_store::client::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Proposal : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Proposal() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::event_store::cluster::ProposalRequest, ::event_store::client::Empty>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::event_store::cluster::ProposalRequest, ::event_store::client::Empty>* streamer) {
                       return this->StreamedProposal(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Proposal() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Proposal(::grpc::ServerContext* /*context*/, const ::event_store::cluster::ProposalRequest* /*request*/, ::event_store::client::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedProposal(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::event_store::cluster::ProposalRequest,::event_store::client::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Accept : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Accept() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::event_store::cluster::AcceptRequest, ::event_store::client::Empty>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::event_store::cluster::AcceptRequest, ::event_store::client::Empty>* streamer) {
                       return this->StreamedAccept(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Accept() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Accept(::grpc::ServerContext* /*context*/, const ::event_store::cluster::AcceptRequest* /*request*/, ::event_store::client::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedAccept(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::event_store::cluster::AcceptRequest,::event_store::client::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_LeaderIsResigning : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_LeaderIsResigning() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::event_store::cluster::LeaderIsResigningRequest, ::event_store::client::Empty>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::event_store::cluster::LeaderIsResigningRequest, ::event_store::client::Empty>* streamer) {
                       return this->StreamedLeaderIsResigning(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_LeaderIsResigning() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status LeaderIsResigning(::grpc::ServerContext* /*context*/, const ::event_store::cluster::LeaderIsResigningRequest* /*request*/, ::event_store::client::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedLeaderIsResigning(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::event_store::cluster::LeaderIsResigningRequest,::event_store::client::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_LeaderIsResigningOk : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_LeaderIsResigningOk() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::event_store::cluster::LeaderIsResigningOkRequest, ::event_store::client::Empty>(
            [this](::grpc_impl::ServerContext* context,
                   ::grpc_impl::ServerUnaryStreamer<
                     ::event_store::cluster::LeaderIsResigningOkRequest, ::event_store::client::Empty>* streamer) {
                       return this->StreamedLeaderIsResigningOk(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_LeaderIsResigningOk() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status LeaderIsResigningOk(::grpc::ServerContext* /*context*/, const ::event_store::cluster::LeaderIsResigningOkRequest* /*request*/, ::event_store::client::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedLeaderIsResigningOk(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::event_store::cluster::LeaderIsResigningOkRequest,::event_store::client::Empty>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_ViewChange<WithStreamedUnaryMethod_ViewChangeProof<WithStreamedUnaryMethod_Prepare<WithStreamedUnaryMethod_PrepareOk<WithStreamedUnaryMethod_Proposal<WithStreamedUnaryMethod_Accept<WithStreamedUnaryMethod_LeaderIsResigning<WithStreamedUnaryMethod_LeaderIsResigningOk<Service > > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_ViewChange<WithStreamedUnaryMethod_ViewChangeProof<WithStreamedUnaryMethod_Prepare<WithStreamedUnaryMethod_PrepareOk<WithStreamedUnaryMethod_Proposal<WithStreamedUnaryMethod_Accept<WithStreamedUnaryMethod_LeaderIsResigning<WithStreamedUnaryMethod_LeaderIsResigningOk<Service > > > > > > > > StreamedService;
};

}  // namespace cluster
}  // namespace event_store


#endif  // GRPC_cluster_2eproto__INCLUDED
